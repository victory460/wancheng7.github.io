<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从输入URL到页面加载发生了什么]]></title>
    <url>%2Fpost%2Fe277deca.html</url>
    <content type="text"><![CDATA[大体过程 浏览器的地址栏输入URL并按下回车 浏览器检查当前URL是否存在缓存，并比较缓存是否过期 DNS解析URL对应的IP 根据IP建立TCP连接（三次握手） HTTP发起请求 服务器处理请求，浏览器接收HTTP响应 渲染页面，构建DOM树 关闭TCP连接（4次挥手） 具体过程的理解浏览器缓存大体上来说，可以分为强缓存和协商缓存 强缓存 强缓存主要通过http响应头中的==Cache-Control==和==Expires==两个字段来控制的 1Expires: Wed, 21 Oct 2015 07:28:00 GMT Expires是HTTP/1.0标准下的字段，上例表示该资源会在Wed, 21 Oct 2015 07:28:00 GMT之后过期，在这个时间点之前都是直接读取缓存不会发起请求的。这种方式有一个很大的问题就是服务器时间和本地时间可能不一致或者说是修改了本地时间也会造成缓存失败。 1Cache-control: max-age=30 Cache-Control出现于HTTP/1.1，优先级高于Expires，上面这个表示该资源会在30秒之后过期，还有其他值可选，详情查看文档 协商缓存 如果缓存过期了，我们就要用协商缓存来解决问题，也就是说协商缓存是需要请求的，如果缓存有效会返回304。协商缓存通过HTTP的Last-modified,Etag字段进行判断 ==Last-Modified==是一个响应头字段，包含的是服务器认定的资源做出修改的日期及时间。下次请求时==If-Modified-Since==这个请求头字段会将Last-Modified发送给服务器，问服务器在该日期之后资源是否有更新，没有更新的话返回一个不带消息主体的304响应，有更新的话会返回新资源，并且响应头中会的Last-Modified会带有最新文件修改时间。 ==ETag==是一个响应头字段，类似于文件指纹，==If-None-Match==会将当前的ETag发送给服务器，服务器验证目前文件的ETag跟请求的ETag是否一致，如果一致，就返回不带任何内容的304未修改状态，如果不一致就返回最新资源。 DNS解析DNS解析实际上就是将我们熟悉的域名解析成IP地址，也就是说当你在浏览器地址栏输入www.baidu.com时实际上访问的是这个域名对应的唯一IP地址，之所以当初要这样设计，是因为IP地址是由纯数字组成的，不便于记忆，而通过几级域名这种方式是便于我们人类记忆的。 DNS解析是一个递归查询的过程，从右到左解析的，有一个专门的DNS解析服务器，据说要经历8个步骤，具体过程我们了解不多，就不过多解释了。 建立TCP连接的三次握手这一块InterviewMap讲的比较详细了 浏览器渲染页面的过程 处理HTML并构建DOM树 处理CSS构建CSSOM树 将DOM树和CSSOM树合并成一个渲染树 根据渲染树来布局，计算每个节点的位置（回流） 调用GPU绘制，合成图层，显示在屏幕上（重绘） 总结既然大体知道了浏览器从输入URL到页面加载的过程，那就可以针对这个过程一些可优化的点做优化，这也成了前端性能优化的一个重要部分，关于这部分，我会另写一篇文章来总结。 参考文章 腾讯前端面试篇（二） InterviewMap 前端缓存最佳实践 趣讲CDN]]></content>
      <tags>
        <tag>浏览器加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS常用操作方法图表]]></title>
    <url>%2Fpost%2Ff1c2f10e.html</url>
    <content type="text"><![CDATA[截取字符串方法 方法名 参数 返回值 例子 String.prototype.substr() (indexStart, length) 都可为负数，length为负数时自动转为0，length不传默认截取剩下的所有 新字符串 ‘JavaScript’.substr(4, 6) // “Script” String.prototype.substring() (indexStart, indexEnd) 负数会转为0 新字符串 ‘JavaScript’.substring(-4) // “JavaScript” String.prototype.slice() (indexStart, indexEnd) 负数会转为与长度相加之后的数 新字符串 ‘JavaScript’.slice(-4) // “ript” 三者区别： 他们三者第二个参数都是可选的，如果只传一个正常下标的数字，都是返回从这个下标开始到字符串结束的这一段字符串，他们都不会改变原字符串 substr截取的是从indexStart下标开始长度为length的字符串，substring和slice两个参数都是开始和结束的下标，并且都不包含结束下标的字符 substring和slice参数如果为负数，substring会转为0，而slice会转为与字符串的长度相加之后的新下标 截取数组方法 方法名 参数 返回值 例子 Array.prototype.slice() (indexStart, indexEnd) 如果slice方法的参数是负数，则表示倒数计算的位置 新数组 [‘a’, ‘b’, ‘c’].slice(1, 2) //[‘b’] Array.prototype.splice() (indexStart, count, addElement1, addElement2,…) 如果只传一个参数就相当于把原数组拆分为截断了 被删除的元素,改变原数组 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’].splice(4, 2); // [“e”, “f”] 两者区别： 只传一个正常下标，都能得到从这个下标开始到数组结束的一个新数组 slice不会改变原数组，返回值是新数组，splice会改变，返回值是被删除的元素 slice能够删除原数组中的某些元素，并能在删除的位置添加新成员 tips: slice方法还有一个重要的应用，可以将类数组对象转为数组 1Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;) //[&apos;a&apos;, &apos;b&apos;] Array.from也可以做到 1Array.from(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;) //[&apos;a&apos;, &apos;b&apos;] 常用数组方法12345var arr = [1, 2, 3];let arr2 = [&apos;今天天气不错&apos;, &apos;早上好&apos;]arr2 = arr2.map(s =&gt; s.split(&apos;&apos;))// [ [ &apos;今&apos;, &apos;天&apos;, &apos;天&apos;, &apos;气&apos;, &apos;不&apos;, &apos;错&apos; ], [ &apos;早&apos;, &apos;上&apos;, &apos;好&apos; ] ] 方法名 参数和说明 返回值 例子 Array.isArray() arr Boolean Array.isArray(arr) // true Array.prototype.valueOf() 无 数组本身 arr.valueOf() // [1, 2, 3] Array.prototype.toString() 无 数组的字符串形式 arr.toString() // “1,2,3” Array.prototype.push() elementN，尾部插入值 新的length arr.push(7) // 4 Array.prototype.pop() 无 删除的元素,删除最后一个元素 arr.pop() // 3 Array.prototype.shift() 无 删除的元素,删除第一个元素 arr.shift() // 1 Array.prototype.unshift() elementN，首部插入值 新的length arr.shift(7) // 4 Array.prototype.join() separator,默认为’’,’ 字符串 arr.join(‘ ‘) // “1 2 3” Array.prototype.concat() array,object,elementN 新数组（浅拷贝） arr.concat([7]) // [1, 2, 3, 7] Array.prototype.reverse() 无 颠倒排序之后的原数组 arr.reverse() // [3, 2, 1] Array.prototype.sort() 无，默认按字典排序，或者传入一个函数 重新排序之后的原数组 arr.sort() // [1, 2, 3] Array.prototype.map() 回调函数，把每次的执行结果重新组成一个数组 新数组 arr.map(function (n) { return n + 1; }); //[2,3,4] Array.prototype.forEach() 回调函数，操作原数组 不返回值，改变原数组 arr.forEach(function (n) { console.log(n) }); //1 2 3 Array.prototype.filter() 回调函数，根据筛选项条件得到新数组 新数组 arr.filter(function (item) { return (item &gt; 2) }); //[3] Array.prototype.some() 回调函数，某一个元素满足条件即返回true，否则返回false Boolean arr.some(function (item) { return item &gt; 2 }); //true Array.prototype.every() 回调函数，所有元素满足条件即返回true，否则返回false Boolean arr.every(function (item) { return item &gt; 2 }); //false Array.prototype.reduce() (func, 初始值)，从左到右 执行之后的返回值 arr.reduce(function (prev, cur) { return prev+cur }, 10); //16 Array.prototype.reduceRight() (func, 初始值)，从右到左 执行之后的返回值 arr.reduceRight(function (prev, cur) { return prev+cur }, 10); //16 Array.prototype.indexOf() (searchElement,fromIndex)第二个参数是开始查找的位置 存在返回索引值，没有返回-1 arr.indexOf(2); //1 Array.prototype.lastIndexOf() (searchElement,fromIndex)第二个参数是开始查找的位置，从右到左 存在返回索引值，没有返回-1 arr.lastIndexOf(3); //2 ES6 Array.from() 类似数组的对象和可遍历的对象 真正的数组 Array.from({‘0’: ‘a’,’1’: ‘b’,’2’: ‘c’, length: 3}); // [“a”, “b”, “c”] Array.of() 将一组值转为数组，为了弥补Array()参数不同的行为差异 数组 Array.of(1,2,3); // [1, 2, 3] Array.prototype.includes() (searchElement,fromIndex)，fromIndex可选，便是开始查找的位置 Boolean [1, 2, 3].includes(2); ; // true Array.prototype.flat() depth,可选参数，默认1，将嵌套数组拉平变成一维数组 新数组 [1, 2, [3, 4, [5, 6]]].flat(2); // [1, 2, 3, 4, 5, 6] Array.prototype.flatMap() callback， 新数组 arr2.flatMap(s =&gt; s.split(‘’)); // [“今”, “天”, “天”, “气”, “不”, “错”, “早”, “上”, “好”] Array.prototype.copyWithin() (target, start, end) 将start和end之间的元素复制覆盖target指定的位置，end指定的元素不会复制 数组 [1,2,3,4].copyWithin(1, 2, 3); // [1, 3, 3, 4] Array.prototype.find() (callback, thisArg) 返回符合条件的第一个值,否则unfettered [1,2,3,4,5].find(function(item){ return item&gt;2 }); // 3 Array.prototype.findIndex() (callback, thisArg) 返回符合条件的第一个值的下标,否则unfettered [1,2,3,4,5].findIndex(function(item){ return item&gt;2 }); // 2 Array.prototype.fill() (value, start, end )，将指定的位置填充为value，如果不指定就全部填充 修改后的数组 [1,2,3,4].fill(7, 2, 3); // [1, 2, 7, 4] Array.prototype.entries() 无 可遍历的Iterator对象,[key, value] [1,2,3,4].entries(); // 可被for of遍历 Array.prototype.keys() 无 可遍历的Iterator对象, key [1,2,3,4].keys(); // 可被for of遍历 Array.prototype.values() 无 可遍历的Iterator对象, value [1,2,3,4].values(); // 可被for of遍历 字符串处理方法 方法名 参数和说明 返回值 例子 String.fromCharCode() 一个或多个数值，代表Unicode 码点 字符串 String.fromCharCode(104, 101, 108, 108, 111) // ‘hello’ String.prototype.charAt() index,下标 字符串 new String(‘abc’).charAt(1) //b String.prototype.charCodeAt() index,下标 Unicode 码点（十进制表示） ‘hello’.charCodeAt(1) // 101 String.prototype.concat() string2…stringN 字符串 ‘hello’.concat(‘world’, ‘haha’) // “helloworldhaha” String.prototype.indexOf() searchValue,fromIndex 第一次出现的索引,没找到就-1 ‘hello’.indexOf(‘e’) // 1 String.prototype.lastIndexOf() searchValue,fromIndex 第一次出现的索引 ‘wanwan’.lastIndexOf(‘a’); //4 ‘wanwan’.lastIndexOf(‘a’, 3) //1 String.prototype.trim() 无，删除字符串两端空白字符串 新字符串 ‘ wan ‘.trim() // ‘wan’ String.prototype.toLowerCase() 无，小写 新字符串 ‘wanCheng’.toLowerCase() // ‘wancheng’ String.prototype.toUpperCase() 无，大写 新字符串 ‘wanCheng’.toUpperCase() // ‘WANCHENG’ String.prototype.match() regexp array ‘wancheng’.match(‘wan’) // [‘wan’] ‘wancheng’.match(/\w/) // [‘w’] String.prototype.search() regexp 首次匹配成功的索引，不成功为-1 ‘wancheng’.search(‘c’) // String.prototype.replace() regexp 新字符串 ‘wan cheng’.replace(/wan/i, ‘san’) // “san cheng” ES6 String.prototype.includes() searchString,position(可选) boolean ‘hello world’.includes(‘hello’) // true String.prototype.startsWith() searchString,position(可选),是否是以给定的字符串开头 boolean ‘hello world’.startsWith(‘h’) // true String.prototype.endsWith() searchString,position(可选),是否是以给定的字符串结尾 boolean ‘hello worlds’.endsWith(‘s’) // true String.prototype.repeat() count（[0, +∞]） 新字符串 ‘wan’.repeat(2) // ‘wanwan’ String.prototype.padStart() targetLength,padString (可选) 原字符串 ‘abc’.padStart(7, ‘sd’) // “sdsdabc” String.prototype.padEnd() targetLength,padString (可选) 原字符串 ‘abc’.padEnd(7, ‘sd’) // “abcsdsd”]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试技巧与技术栈准备梳理]]></title>
    <url>%2Fpost%2Fe7b60f06.html</url>
    <content type="text"><![CDATA[前言这个是我之前看前端跳槽面试必备技巧这个系列视频整理的一个笔记，其中还有一些内容没有细化，会持续更新细化内容。比较短的就会直接写在下面，长一点的就单独写篇文章。 说实话，这个大佬真的讲的挺好的，尤其是对原型和继承那一块讲的通俗易懂。有些店之前看视频的时候看不懂或者没有在意，其实还是有蛮多点可挖的，我也还会针对一些没太吃透的点重点再写文章记录。 1.面试准备1.1 对职位描述的分析 首先要逐条读懂职位描述中对岗位能力的要求，在真实的面试投递之前通过这个分析首先就可以知道要面试的这个岗位与自己能力的匹配程度，不过平时根据自己的目标薪资浏览岗位描述时就一定要细化自己具体哪个点不足，以及如何补上或者提高相应能力。 具体来说岗位描述分为基础能力和难度点 职位描述的目的一个是快速识别这个岗位是不是自己喜欢的是不是自己想要的，二个是我能不能胜任这个岗位或者说经过准备短期内hold住这个岗位 具备前端工程化知识已经成为一名合格前端的基本要求，具体到技术就是要了解并使用过==webpack、grunt、gulp、sass、less==这几个。 1.2 针对目标公司的技术栈分析 可以拿目标网站的源码分析，可以看到他们大体上用到了一些什么技术栈，对于那些自己完全没接触过的点一定要重点了解。 2.根据常见面试题梳理知识体系2.1 页面布局 例子：假设高度已知，请写出三栏布局，其中左右栏宽度都是300px，中间自适应 这个问题目前就我已知的有五种解决方案： 12345678910html * &#123; margin: 0; padding: 0;&#125;.layout .item &#123; height: 100px;&#125; .layout &#123; margin-bottom: 30px;&#125; 浮动布局 123456789101112131415161718192021222324252627 &lt;!-- 浮动布局 --&gt;&lt;section class=&quot;layout float&quot;&gt; &lt;style&gt; .layout.float .left &#123; float: left; width: 300px; background-color: #555; margin-right: 10px; &#125; .layout.float .center &#123; background-color: #777; &#125; .layout.float .right &#123; float: right; width: 300px; background-color: #999; &#125; &lt;/style&gt; &lt;article class=&quot;left_center_right&quot;&gt; &lt;div class=&quot;item left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item center&quot;&gt; &lt;h2&gt;浮动布局&lt;/h2&gt; &lt;p&gt;这是浮动布局的内容&lt;/p&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 相对定位 12345678910111213141516171819202122232425262728293031323334 &lt;!-- 绝对布局 --&gt;&lt;section class=&quot;layout absolute&quot;&gt; &lt;style&gt; .layout.absolute .left_center_right .item &#123; position: absolute; &#125; .layout.absolute .left &#123; left: 0; width: 300px; background-color: #555; &#125; .layout.absolute .center &#123; left: 300px; right: 300px; background-color: #777; padding-left: 10px; &#125; .layout.absolute .right &#123; right: 0; width: 300px; background-color: #999; &#125; &lt;/style&gt; &lt;article class=&quot;left_center_right&quot;&gt; &lt;div class=&quot;item left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item center&quot;&gt; &lt;h2&gt;绝对布局&lt;/h2&gt; &lt;p&gt;这是绝对定位布局的内容&lt;/p&gt; &lt;p&gt;这是绝对定位布局的内容&lt;/p&gt; &lt;p&gt;这是绝对定位布局的内容&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; flx布局 (http://www.runoob.com/w3cnote/flex-grammar.html) 以下6个属性设置在容器上 flex-direction (flex-direction属性决定主轴的方向（即项目的排列方向） row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap nowrap（默认）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content (justify-content属性定义了项目在主轴上的对齐方式) flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 align-content (定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用) 竖直方向的 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 以下6个属性设置在项目上 order (order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0) flex-grow (flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大) flex-shrink (flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小) flex-basis: | auto; / default auto / (项目占据的主轴空间) flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选 align-self: auto | flex-start | flex-end | center | baseline | stretch; (align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch)1234567891011121314151617181920212223242526272829303132333435 &lt;!-- flexbox 布局 --&gt;&lt;section class=&quot;layout flexbox&quot;&gt; &lt;style&gt; .layout.flexbox &#123; margin-top: 160px; &#125; .layout.flexbox .left_center_right &#123; display: flex; display: -webkit-flex; &#125; .layout.flexbox .left &#123; width: 300px; background-color: #555; &#125; .layout.flexbox .center &#123;; background-color: #777; flex: 1; padding-left: 10px; &#125; .layout.flexbox .right &#123; width: 300px; background-color: #999; &#125; &lt;/style&gt; &lt;article class=&quot;left_center_right&quot;&gt; &lt;div class=&quot;item left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item center&quot;&gt; &lt;h2&gt;flex布局&lt;/h2&gt; &lt;p&gt;这是flex布局的内容&lt;/p&gt; &lt;p&gt;这是flex布局的内容&lt;/p&gt; &lt;p&gt;这是flex布局的内容&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; table布局 1234567891011121314151617181920212223242526272829303132333435 &lt;!-- table 布局 --&gt;&lt;section class=&quot;layout table&quot;&gt; &lt;style&gt; .layout.table .left_center_right &#123; width: 100%; height: 100px; display: table; &#125; .layout.table .left_center_right .item &#123; display: table-cell; &#125; .layout.table .left &#123; width: 300px; background-color: #555; &#125; .layout.table .center &#123;; background-color: #777; padding-left: 10px; &#125; .layout.table .right &#123; width: 300px; background-color: #999; &#125; &lt;/style&gt; &lt;article class=&quot;left_center_right&quot;&gt; &lt;div class=&quot;item left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item center&quot;&gt; &lt;h2&gt;table布局&lt;/h2&gt; &lt;p&gt;这是table布局的内容&lt;/p&gt; &lt;p&gt;这是table布局的内容&lt;/p&gt; &lt;p&gt;这是table布局的内容&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; grid网格布局 目前浏览器基本上默认不支持，不过可能是未来的一种网页布局方式 开启浏览器grid模块功能 （https://www.w3cplus.com/css3/how-to-enable-support-for-grid-layout-in-various-browsers.html） grid-template-columns： 设置行的宽度 grid-template-rows： 设置列的高度12345678910111213141516171819202122232425262728293031323334 &lt;!-- 网格 布局 --&gt;&lt;section class=&quot;layout grid&quot;&gt; &lt;style&gt; .layout.grid .left_center_right &#123; width: 100%; height: 100px; display: grid; grid-template-columns: 300px auto 300px; grid-template-rows: 100px; &#125; .layout.grid .left &#123; width: 300px; background-color: #555; &#125; .layout.grid .center &#123;; background-color: #777; padding-left: 10px; &#125; .layout.grid .right &#123; width: 300px; background-color: #999; &#125; &lt;/style&gt; &lt;article class=&quot;left_center_right&quot;&gt; &lt;div class=&quot;item left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item center&quot;&gt; &lt;h2&gt;网格布局&lt;/h2&gt; &lt;p&gt;这是grid布局的内容&lt;/p&gt; &lt;p&gt;这是grid布局的内容&lt;/p&gt; &lt;p&gt;这是grid布局的内容&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item right&quot;&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 写代码时要注意几点： 使用标签时要尽量使用语义化标签，不要通篇div 注意缩进与书写的规范化 知道这几种解决方案之后还要思考几个问题： 他们各自的优缺点，通过比较这几种布局方式的不同来在实际开发中知道如何取舍，比如常见的移动端的上下高度固定，中间高度自适应等。 在实际开发中会优先选择哪种解决方案 当高度不固定时又要如何处理 2.2 CSS盒模型 基本概念：标准模型 + IE模型 标准模型和IE模型的区别 两种盒模型都包含content,padding,border,margin这四个部分，不同在与标准模型是将content的宽度和高度计算为盒子的宽度与高度，而IE模型是将content、padding与border之和计算为盒子的宽度与高度 CSS如何设置这两种模型 box-sizing: content-box (标准模型，默认方式) box-sizing：border-box (IE模型) JS如何设置获取盒模型对应的宽和高 dom.style.width/height (这种方法只能取到内联样式中声明的宽或者高) dom.currentStyle.width/height (这种方法得到的是渲染之后的准确结果，但是只有IE支持) window.getComputedStyle(dom).width/height (兼容性更好，能够兼容FF和Chrom) dom.getBoundingClientRect().width/height (能够计算元素的绝对位置，同时也能获得宽高) 实例题（根据盒模型解释边距重叠） BFC （边距重叠解决方案） BFC的基本概念 （块级隔离化上下文） BFC的渲染规则 在BFC的垂直方向的边距会发生重叠 BFC的区域不会与浮动元素的BOX重叠 BFC在页面上是一个独立的容器，容器内与外的元素不会相互影响 计算BFC元素高度时浮动元素也会被计算进去 如何创建BFC float值不为none position的值不是stastic或者reletice overflow table BFC的使用场景 2.3 DOM事件类 基本概念：DOM事件的级别 事件级别123- DOM0: element.onclick=function()&#123;&#125; - DOM1: element.addEventListener(&apos;click&apos;,function()&#123;&#125;,false)- DOM3: element.addEventListener(&apos;keyup&apos;,function()&#123;&#125;,false) (增加了很多事件) DOM事件模型 （捕获和冒泡） DOM事件流 （从捕获阶段到目标阶段再到冒泡阶段） 捕获阶段 (最后那个参数默认是false，是冒泡阶段的，设为true就是捕获阶段的)12345678910111213141516window: window.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;window&apos;);&#125;, true)document:document.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;document&apos;);&#125;, true)html:document.documentElement.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;html&apos;);&#125;, true)body:document.body.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;body&apos;);&#125;, true) 描述DOM事件捕获的具体流程 window –&gt; document –&gt; html –&gt;body –&gt; … –&gt;具体元素 获取document：document.documentElement Event对象的常见应用 12345- event.preventDefault() 阻止默认事件- event.stopProgation() 阻止冒泡- event.stopImmediateProgation() 设定事件响应优先级- event.currentTarget 当前所绑定的事件- event.targe 当前被点击的元素 自定义事件 123456例如：自定义一个自定义事件&apos;custome&apos;var eve=new Event(&apos;custome&apos;);ev.addEventListener(&apos;custom&apos;,function()&#123; console.log(&apos;custome&apos;); &#125;)ev.dispatchEvent(eve); 2.4 HTTP协议类 HTTP协议的主要特点 简单快速 （URL是固定的） 灵活 （通过一个HTTP协议就能完成不同数据类型的传输） 无连接 （连接一次就会断掉） 无状态 （多次连接是无状态的） HTTP报文的组成部分 请求报文（请求行，请求头，空行，请求体） 响应报文（状态行，响应头，空行，响应体） HTTP方法 GET、POST、PUT、DELETE、HEAD（获得报文头部） POST和GET的区别 GET在浏览器回退时时无害的，而POST会再次请求 GET产生的URL地址是可以被收藏，而POST不可以 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求只能进行URL编码，而POST支持多种编码方式 GET请求参数会被完整地保留在浏览器历史记录了，而POST请求不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST请求没有限制 对参数数据类型，GET只接受ASCII字符，而POST没有限制 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息 GET参数通过URL传递，POST放在Request body中 HTTP状态码 1xx：提示信息-表示请求已接收，继续处理 2xx：成功-表示请求已被成功接收 3xx：重定向-要完成请求必须进行更进一步操作 4xx：客户端错误-请求有语法错误或者请求无法实现 5xx：服务器错误-服务器未能实现合法的请求 什么是持久连接 （keep-alive） 什么是管线化 （通道是持久建立的，先发送几个请求，再同时返回这几个请求的结果） 管线化通过持久连接完成，进HTTP1.1支持此技术 只有GET和HEAD请求可以管线化，而POST有所限制 管线化不会影响响应到来的顺序2.5 原型链 创建对象有几种方法 1234567891011 // 第一种很方式：字面量 var o1 = &#123;name: &apos;o1&apos;&#125;;var o11 = new Object(&#123;name: &apos;o11&apos;&#125;); // 第二种方式：通过构造函数var M = function()&#123; this.name = &apos;o2&apos;;&#125;var o2 = new M(); // 第三种方式：Object,createvar P = &#123;name: &apos;o3&apos;&#125;;var o3 = Object.create(P); 原型、构造函数、实例、原型链 任何函数都可以作为构造函数，只要被new了，就是一个构造函数 每个函数都有一个prototype属性，这个是生成函数时自动加上的，函数的这个prototype属性指向的就是函数的原型对象 1M的原型对象：M.prototype 每个原型对象都有一个constructor构造器，这个属性指向的就是引用的那个构造函数，也就是声明这个原型对象的函数 1234M.prototype.constructor === M任意一个实例对象o2o2.__proto__.constructor === M这个可以用来判断实例对象的构造函数 每个对象都有一个proto属性，这个属性指向的是这个的对象的构造函数的的原型对象，也就是说一个实例对象的原型是等于它的构造函数的原型对象 1o2.__proto__ === M.prototype 原型链：所谓原型链就是从一个实例对象向上找，通过查找实例对象的构造函数的原型对象向上找，然后找原型对象的构造函数的原型对象，一直找到构造函数为Object时终止，因为 Object.prototype.proto===null; 这样就形成了一个原型链 原型链：从一个对象上获取某一个属性或者方法时，如果这个对象本身不具备这个属性或者方法，那就会从这个对象的构造函数的原型对象上去找，如果还没找到就会从构造函数的构造函数上去找，直到找到构造函数为Object时终止，因为Object.prototype.proto===null，这样形成的一个链条就叫原型链。1原型链的顶端是Object.prototype这个原型对象的原型Object.prototype.__proto__为空 instanceof原理 判断一个实例对象的instanceof到底是不是一个构造函数时实际上判断的是实例对象的proto属性是否跟这个构造函数的prototype属性相等，在上面的例子中，就是：o2 instanceof M为true，因为o2.proto === M.prototype 并且，只要是在 这个原型链上的构造函数，都会等于这个实例对象的instanceof属性，例如：o2 instanceof M毫无疑问是true的，同时o2 instanceof Object也是true的，因为M.prototype.proto === Object.prototype,Object是在o2的原型链上的一个构造函数 那怎么严谨地判断一个实例对象是不是一个构造函数的实例对象呢，需要用constructor,例如：o2.proto.constructor === M，就可以确定M是o2的构造函数了 new 运算符12345678910var new2 = function(func)&#123; var o = Object.create(func.prototype); var k = func.call(o); if (typeof k === &apos;object&apos;) &#123; return k &#125;else&#123; return o &#125;&#125;o6 = new2(M); 这个就等价于对构造函数M实例化了一个实例对象 2.6 面向对象类 类与实例 类的声明 12345678910 /*类的声明*/ function Animal () &#123; this.name = &apos;name&apos;;&#125;/*ES6中的类的声明*/ class Animal2 &#123; constructor (name) &#123; this.name = name; &#125;&#125; 生成实例 12/*实例化类的对象*/ console.log(new Animal(), new Animal2()) 类与继承 如何实现继承 构造函数(call() 和apply(方法)) 原型链 继承的几种方式 借助构造函数实现继承 12345678910 /*借助构造函数实现继承*/ function Parent1 () &#123; this.name = &apos;parent1&apos;;&#125;function Child1 () &#123; Parent1.call(this); //就是将Child1运行在Parent1的上下文环境里 // Parent1.apply(this, []); //另一中写法 this.type = &apos;child1&apos;;&#125;console.log(new Child1) 利用原型链实现继承 123456789101112131415 /*利用原型链实现继承*/ function Parent2 () &#123; this.name = &apos;parent2&apos;; this.play = [1,2,3];&#125;function Child2 () &#123; this.type = &apos;child2&apos;;&#125;Parent2.prototype.say = function () &#123;console.log(&apos;hello&apos;)&#125;;Child2.prototype = new Parent2(); //实际上这个方法就是相当于把Parent2的原型链嫁接到了Child2上，所以子级能通过原型链访问到父级的方法了console.log(new Child2()); // (new Child2()).__proto__ === Child2.prototype = new Parent2(),所以子集实例的原型链指向的是父级的一个实例var s1 = new Child2();var s2 = new Child2();s1.play.push(7);console.log(s1.play, s2.play); //他们永远会是相等的，因为他们指向的地址是一样的，他们的原型对象是一样的,s1.__proto__===s2.__proto__ 组合方式 1234567891011121314 /*组合方式*/function Parent3 () &#123; this.name = &apos;parent3&apos;; this.play = [1,2,3];&#125;function Child3 () &#123; Parent3.call(this); this.type = &apos;child3&apos;;&#125;Child3.prototype = new Parent3(); //构造函数Parent3执行了两次，有一次是多余的var s3 = new Child3();var s4 = new Child3();s3.play.push(6);console.log(s3, s4) 组合方式优化1 1234567891011121314151617 /*组合方式优化1*/function Parent4 () &#123; this.name = &apos;parent4&apos;; this.play = [1,2,3];&#125;function Child4 () &#123; Parent4.call(this); this.type = &apos;child4&apos;;&#125;Child4.prototype = Parent4.prototype; //这样构造函数Parent4就只执行了一次console.log(Parent4.prototype)var s5 = new Child4();var s6 = new Child4();var s6_ = new Parent4();console.log(s5 instanceof Child4, s5 instanceof Parent4);console.log(s5.constructor);console.log(s6_.constructor); //都指向了构造函数Parent4 组合方式优化2 （比较完美的解决方案） 123456789101112131415161718 /*组合方式优化2*/// 这种优化方式是为了解决无法分辨父级和子级的实例对象的问题，也就是说父级和子级的实例对象都指向了同一个原型对象function Parent5 () &#123; this.name = &apos;parent5&apos;; this.play = [1,2,3];&#125;function Child5 () &#123; Parent5.call(this); this.type = &apos;child5&apos;;&#125;Child5.prototype = Object.create(Parent5.prototype); //相当于创建了一个空的中间对象，这样的话子级构造函数的原型对象不是简单地与父级构造函数的原型函数相等了，而是先等于一个空的中间对象，再对这个中间的对象进行赋值Child5.prototype.constructor = Child5; //这一步实际上就是做的赋值，当然没有上面那步让子级的构造函数的原型对象先等于一个空对象的话还是无法将他们分开的var s7 = new Child5();var s8 = new Child5();var s9 = new Parent5();console.log(s7 instanceof Child5, s8 instanceof Parent5)console.log(s7.constructor)console.log(s9.constructor) 2.7 通信类 什么是同源策略及限制 协议、域名、端口这三个构成了一个源，这三个之中有一个不一样就是源不一样了，就是跨域了。所以不是同一个源是不能操作同源的文件 Cookie、LocalStorage、和indexDB无法读取 DOM无法获得 AJAX请求不能发送 前后端如何通信 Ajax （受同源策略限制） WebSocket （不受同源策略限制） CORS （支持跨域通信，也支持同源通信） 如何创建Ajax 跨域通信的几种方式 JSONP 原理：利用js、css，img等标签可以加载跨域资源的原理，动态创建script标签，再请求一个带参网址实现跨域通信。 缺点：只能实现get请求 跨域资源共享（CORS） 原理：普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。(withCredentials) nginx代理跨域 原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不存在同源策略，也就不存在跨域问题。 Nodejs 中间件代理 原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发 WebSocket协议跨域 原理:WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯 document.domain + iframe跨域 原理：此方案仅限主域相同子域不同的的跨域场景。两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 location.hash + iframe跨域 原理：a域与b跨域相互通信，通过中间页c来实现。三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 window.name + iframe跨域 原理：window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB） postMessage跨域 (H5中新增的) 原理：postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一 2.8 安全类 CSRF 基本概念：跨站请求伪造 特点是用户一定在注册网址登录过 被攻击网站本身存在漏洞 防御措施： Token验证 Referer验证 隐藏令牌 XSS 基本概念：跨域脚本攻击 2.9 渲染机制类 什么是DOCTYPE及作用 说白了就是告诉浏览器文档类型 浏览器的简要渲染过程 解析HTML–&gt;构建DOM树(DOM Tree) 加载样式–&gt;解析样式–&gt;构建样式规则树(CSS Tree) 加载js–&gt;执行js代码 把DOM树和样式规则树匹配构建渲染树(Render Tree) 计算元素进行布局 (Layout) 绘制 (Paiting) 图片记载和渲染的时机 解析HTML【遇到标签加载图片】–&gt;构建DOM树 加载样式–&gt;解析样式 【遇到背景图片链接不加载】–&gt;构建样式规则树 加载js–&gt;执行js代码 把DOM树和样式规则树匹配构建渲染树【加载渲染树上的背景图片】 计算元素位置进行布局 绘制【开始渲染图片】 设置了display:none属性的元素，图片会加载，但不会渲染出来，而这个设置了display:none的子元素不会渲染，也不会加载。 https://mp.weixin.qq.com/s?__biz=MzAwNjI5MTYyMw%3D%3D&amp;mid=2651494431&amp;idx=1&amp;sn=ab0f92186e44c8e4575c9c0c831ad6cc&amp;chksm=80f191d7b78618c11a4489b39af45e3279f5248843d2b05804aebecc13678a45432116260e03 浏览器渲染过程 Create/Update DOM And request css/image/js：浏览器请求到HTML之后，生成DOM树，并同时请求相应的CSS，js文件 Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM Create/Update Render Tree：CSSOM树构建完之后和DOM一起生成Render Tree Layout: 浏览器根据render tree上各个节点的样式信息计算各个点在屏幕中的位置 Painting：按照计算出来的规则，通过显卡，把内容画到屏幕上 重排Reflow 定义：浏览器根据各种样式计算记过将各种DOM元素放到它该出现的位置，这个过程就是Reflow 触发条件： 增加、删除、修改DOM节点，绘导致Reflow或Repaint 移动DOM位置或者动画 修改CSS样式 Resize窗口或者滚动的时候 修改网页的默认字体时 重绘Repaint 定义：页面要呈现的内容统统画在屏幕上 触发： DOM改动 CSS改动 布局Layout 2.10 运行机制类 JS是单线程的，从上到下执行，但是任务又分为同步任务和异步任务，绘先执行同步任务，把异步任务先挂起，等同步任务完成了再执行异步任务 同步人物和异步任务的优先关系123456console.log(1);setTimeout(function()&#123; console.log(2)&#125;, 0)console.log(3);打印顺序是：1，3，2，因为setTimeout是异步任务 123456789console.log(&apos;A&apos;);setTimeout(function()&#123; console.log(&apos;C&apos;);&#125;,0)while(1)&#123; console.log(5) &#125;console.log(&apos;B&apos;);会输出：A; 因为while是一个同步任务，会优先执行这个任务，但是这个while循环是一个死循环，会一直陷在循环中，那后面的打印和定时器的异步任务都不会执行了 异步对垒执行时间：浏览器有一个time模块，专门识别setTimeou和setInterval，当遇到这两种方法时会先将他们挂起，等到时间到了，才会放到异步队列中去执行 123456for (var i = 0; i &lt; 4; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;,1000)&#125;输出结果: 4个4 如何理解JS的单线程 一个时间之内JS只能干一件事 什么是任务队列 分为同步任务和异步任务，异步任务后于同步任务执行 什么是EventLoop 异步任务 setTimeout和setInterval DOM事件 ES6中的promise 2.11 页面性能类 资源压缩合并，减少HTTP请求 非核心代码异步加载 异步加载的方式 动态脚本加载 defer async 异步加载的区别 defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行 async实在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关 利用浏览器缓存 缓存的分类 强缓存：相对时间、绝对时间 协商缓存 缓存的原理 使用CDN 预解析DNS1234&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;这句话是说在https协议下默认强制让页面上所有的a标签也可以DNS预解析&lt;link rel=&quot;dns-prefetch&quot; href=&quot;..&quot;&gt;针对某一个域名DNS预解析]]></content>
      <tags>
        <tag>知识点整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记（二）—— 通过ES6 Module看import和require区别]]></title>
    <url>%2Fpost%2F594701d3.html</url>
    <content type="text"><![CDATA[前言说到import和require，大家平时开发中一定不少见，尤其是需要前端工程化的项目现在都已经离不开node了，在node环境下这两者都是大量存在的，大体上来说他们都是为了实现JS代码的模块化，那为什么会出现两种方案呢，又有什么不同呢？ 模块化的不同解决方案追根溯源，JS这门脚本语言设计伊始就是没有模块化的，所以早期的全局变量容易造成命名冲突。但随着web项目越来越大，JS的代码量也与日俱增，于是社区就自发约定了几种模块化的方案：requirejs遵循AMD，seajs遵循CMD，node的module遵循CommonJS规范，虽然写法上有所不同，都是为了能够间接实现模块化的基础上保持较为一致的代码风格。 随着ES2015的发布，官方标准定义了一种模块化的方案，那就是import、export。可是，标准毕竟是标准，各大浏览器和node终端要实现标准还是有一段距离的，目前来说都2018年了主流浏览器都还没实现，还得依赖转换工具（例如babel）转为ES5的代码之后浏览器才能解析。所以这也就解释了为什么我们的工程化代码中nodeJS遵循的CommonJS规范和ES6的模块化方案并存的现象。 两者的区别 import是ES6标准中的模块化解决方案，require是node中遵循CommonJS规范的模块化解决方案 后者支持动态引入，也就是require(${path}/xx.js)，前者目前不支持，但是已有提案 前者是关键词，后者不是 前者是编译时加载，必须放在模块顶部，在性能上会比后者好一些，后者是运行时加载，理论上来说放在哪里都可以 前者采用的是实时绑定方式，即导入和导出的值都指向同一个内存地址，所以导入值会随着导出值变化。而后者在导出时是指拷贝，就算导出的值变化了，导入的值也不会变化，如果想要更新值就要重新导入 前者会编译成require/exports来执行 用法上的区别import导入模块 导入模块根据模块导出时的写法有不同写法，具体可以参考这里，如果模块是普通导出： 123456789101112 // test.js var firstName = &apos;Michael&apos;; var lastName = &apos;Jackson&apos;; var year = 1958; export &#123;firstName, lastName, year&#125;; // demo.js import &#123; firstName &#125; from &apos;./test.js&apos; console.log(firstName); // &apos;Michael&apos; import * as test from &apos;./test.js&apos; console.log(test); //Module&#123;&#125; 所有内容 import &#123; firstName as key, lastName as value &#125; from &apos;./test.js&apos;console.log(key + &apos;--&apos; + value); // Michael--Jackson 带有默认值时，也是我们日常开发中常用的方式: 12345678// test.jsvar firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;export default &#123; firstName, lastName, year &#125;;// demo.jsimport test from &apos;./test.js&apos;console.log(test); // &#123;firstName: &quot;Michael&quot;, lastName: &quot;Jackson&quot;, year: 1958&#125; 实际上这个default就是一个语法糖，只不过defaul是一个关键字，在这里等同于 1import &#123; default as test &#125; from &apos;./test.js&apos; 特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。可以理解为export导出的是一种引用关系而不是一个具体的值，它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系，例如下面这样就会报错： 123export 1;var m = 1;export m; 但是改为用花括号包起来变成对象之后就成了输出引用关系就可以正常导出了： 12var m = 1;export &#123; m &#125; require导入模块 require导入模块就没那么复杂了，导出时是什么样，导入时就还是什么样： 12345678// test.jsvar firstName = &apos;Michael&apos;;var lastName = &apos;Jackson&apos;;var year = 1958;module.exports = &#123; firstName, lastName, year &#125;;// demo.jsconst test = require(&apos;./test.js&apos;);console.log(test); // &#123;firstName: &quot;Michael&quot;, lastName: &quot;Jackson&quot;, year: 1958&#125; 还有一种不常用的用法，直接导出： 123456// test.jsvar year = 1958;exports.year = year;// demo.jsconst test = require(&apos;./test.js&apos;);console.log(test); // &#123;year: 1958&#125; 需要注意的是，module.exports导出之后，后面的代码就对导出的模块无效了，例如上例中 123456// test.jsmodule.exports = &#123; firstName, lastName, year &#125;;exports.name = &apos;222&apos;;// demo.jsconst test = require(&apos;./test.js&apos;);console.log(test); // &#123;firstName: &quot;Michael&quot;, lastName: &quot;Jackson&quot;, year: 1958&#125; 特别说明一下，由于require是可以在任意地方引入的，所以，我们在开发中用~引入图片的方式实际上等效于require: 123&lt;img src=&quot;~assets/img/icon/red_logo.png&quot; class=&quot;logo&quot; alt=&quot;&quot;&gt;//等效于&lt;img :src=&quot;require(&apos;assets/img/icon/red_logo.png&apos;)&quot; class=&quot;logo&quot; alt=&quot;&quot;&gt; 总结import和require就是两种不同的JS模块化实现方式而已，由于之前npm生态的很多包都是基础CommonJS规范写的，所以相当一段时间之内必然是import和require这两种模块引入方式共存的。 总体来说时代总是发展的，ES6作为语言规范是迟早会被各大主流浏览器支持的，不然也就称不上主流浏览器了。所以为了长远考虑，我们还是尽量使用ES6的import来引入模块，等以后浏览器支持了我们也就可以少改一些代码了。 参考 阮一峰ES6-export命令 Node中没搞明白require和import，你会被坑的很惨 require 和 import 的区别？ require和import的区别是什么？看这个你就懂了]]></content>
  </entry>
  <entry>
    <title><![CDATA[我所理解的event loop]]></title>
    <url>%2Fpost%2F5d54f45f.html</url>
    <content type="text"><![CDATA[灵魂三问 JS为什么是单线程的 我们都知道，JS是单线程的语言，那为什么呢？我的理解是JS设计之初就是为了在浏览器端完成DOM操作和一些简单交互的，既然涉及到DOM操作如果是多线程就会带来复杂的同步问题，比较极端的例子就是两个线程可能一个在删除某个DOM节点一个却在修改这个DOM节点，这是浏览器以哪个线程为准呢？ 为什么需要异步 如果没有异步，单线程的JS从上到下执行遇到一段代码需要执行比较久时就会阻塞页面的渲染，造成页面假死，这显然是一种很差的用户体验 单线程又是如何实现异步的呢 单线程之所以能实现异步是因为在处理异步任务时并不是马上运行的，而是通过一个事件循环(event loop)机制来管理任务的执行。貌似是浏览器提供了这么一个管理任务的event loop线程，它来管理和负责向我们的主线程上输送需要执行的任务。所以理解了event loop的机制才能更好地理解JS的运行机制，理解JS的运行机制才能更准确地把握我们代码的运行规律。 由一个面试题引发的思考首先来看一道考察JS执行机制的面试题，原题是今日头条的前端面试题，我稍微进行了一点改造：12345678910111213141516171819202122232425262728293031async function async1() &#123; console.log( &apos;async1 start&apos; ) await async2() console.log( &apos;async1 end&apos; )&#125;async function async2() &#123; new Promise( function ( resolve ) &#123; console.log( &apos;11&apos; ) resolve(); &#125;).then( function () &#123; console.log( &apos;22&apos; ) &#125;)&#125;console.log( &apos;script start&apos; )setTimeout( function () &#123; console.log( &apos;setTimeout&apos; )&#125;, 0 )async1();new Promise( function ( resolve ) &#123; console.log( &apos;promise1&apos; ) resolve();&#125;).then( function () &#123; console.log( &apos;promise2&apos; )&#125;)console.log( &apos;script end&apos; ) 看完之后如果不在浏览器端运行一下你能有自己的答案吗，并且能自圆其说吗？得到答案都不难，放在浏览器里自然就有了输出：123456789script startasync1 start11promise1script end22promise2async1 endsetTimeout 因为题目是千变万化的，日常开发中的情况也是多种多样的，正确理解了其中的执行规律才能更好地开发，当然如果你得到的结果是一样的并且能够自圆其说那也就没必要看下去了，如果你还对这个结果有点懵那就听听我的理解吧。 微任务与宏任务事实上，我们的JS代码用同步和异步这两种划分方式来决定执行的先后顺序显然是不够的，从而有了另一种划分方式，具体谁提出来的我就没考证了，大体上大家是这样分的： macro-task(宏任务)：整体代码script，setTimeout，setInterval micro-task(微任务)：Promise的then回调，process.nextTick(Node) 因为我们上面的面试题是前端面试题，所以我们讨论的都是浏览器环境下的表现，node环境下的event loop貌似有些不一样，这里就不讨论了。 event loop的运行机制既然前端谈到了JS是单线程的，同时只能处理一个任务，而我们又将各种各样的任务分为了宏任务和微任务，那到底哪种任务先执行了，这个运行逻辑就是event loop的判断逻辑。 先说说我的理解，再来印证上面代码的运行顺序： 一段代码执行时先执行宏任务中的同步代码 如果遇到像setTimeout这类宏任务就会把代码方式【宏任务队列】中 如果遇到像Promise.then()这类微任务会放入【微任务队列】 在本轮宏任务中的同步代码执行完之后就会依次执行本轮微任务队列中的代码，然后执行下一轮中的宏任务代码 说回上面的面试题，我们模拟event loop来首先给他们归个队 首先遇到了console.log( ‘script start’ )，直接打印 然后遇到了setTimeout这个宏任务，就被推到宏任务队列中 然后是async1()，直接打印同步代码console.log( ‘async1 start’ ) 关于await async2()，实际上是从右到左先执行了async2()里的代码，然后遇到await从而交出线程的控制权的，async2()执行之后先打印了11，console.log( ‘22’ )被推入了微任务队列 接着执行Promise中的同步代码console.log( ‘promise1’ )，然后将console.log( ‘promise2’ )推入微任务队列 接着打印同步代码console.log( ‘script end’ )，到此，所有同步代码执行完毕 接下来就要执行本轮代码中的微任务队列了，所以先打印22，再打印promise2 至此，await等待的async2()执行完了，可以执行await下面的代码了，所以接下来打印async1 end 最后，就是执行下一轮event loop中的宏任务setTimeout，最后打印setTimeout 单独说一下async和awaitasync本质上是加上了Generator函数并且内置了执行器的一个语法糖，并且async函数返回的是Promise对象。唯一需要注意的是await后面无论接的是同步代码还是异步代码都要等他们执行完毕才能执行await结果之后的代码。并且经过验证，当遇到await语句时是从右到左先执行的await后面的代码，然后才交出线程的控制权直到await等待的结果运行完毕。 总结总体上，算是能对上面那个题目的执行过程有了一个能自圆其说的解释，只是吧，为什么规则是这样的呢？这些规则怎么证伪呢？这是我查资料的时候最纠结的问题。后来跟同事交流了之后吧，觉得也没必要纠结，毕竟最终的解释器是C写的，不懂规则可以去看源码啊，可是我看不懂啊，哈哈。。。所以，既然大家大部分人都是这么说，也能说得通，暂且先记着吧，至少，还是能够解释日常中形形色色代码的运行规律的。 看了几篇不同观点的文章之后重新梳理一下event loop的顺序： 先执行宏任务中的同步代码 执行栈清空之后查询任务队列 如果任务队列中有微任务，先执行 执行完了微任务之后开始下一轮event loop，执行队列中宏任务的异步代码 参考文章中有几篇文章比我讲的生动一些，没看懂的可以参考一下，我主要是梳理一下自己的理解，有不同想法的欢迎交流。 参考文章 微任务、宏任务与Event-Loop 8张图帮你一步步看清 async/await 和 promise 的执行顺序 10分钟理解JS引擎的执行机制 理解 JavaScript 的async/await 浅谈js运行机制(线程） 从setTimeout-setInterval看JS线程]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在npm上发布一个自己的包]]></title>
    <url>%2Fpost%2Fb43e440c.html</url>
    <content type="text"><![CDATA[准备工作首先，要在https://www.npmjs.com网站注册一个账号，具体过程就不说了，很简单。然后最重要的就是要准备好自己要发布的项目包。 发布 如果是一个新项目，就要先初始化一下 1$ npm init 跟着引导填写好相关信息即可 然后需在在本地添加npm用户, 填上对应的注册信息即可 1234$ npm adduserUsername: your namePassword: your passwordEmail: your email 发布 1$ npm publish 当执行npm publish 时，出现unauthorized 和 is not in the npm registry 1$ npm config set registry https://registry.npmjs.org/ 需要注意的是，替换完镜像之后要重新执行 npm adduser 、 npm publish 删除已发布的包 强制删除当前本机版本的包 1$ npm unpublish --force 删除指定版本的包 1$ npm unpublish guitest@1.0.1 //指定版本号 不过这个需要注意的是，在npm上自己有发布多个版本时可以删除任意版本，但只剩一个版本时就不能删除了，貌似是因为之前一个大牛把他的包删了结果导致很多依赖的包出问题了，所以官方更新了删除机制，只要在发布半小时之内没删除的，就不能彻底删除包了。 更新包更新的话也是运行publish，但是版本号必须要变动，不然是发布不成功的，在package.jason中修改version就可以发布新的版本了。 参考 发布npm包，删除npm包 如何开发一个npm包并发布 npm发布一个包 当执行npm publish 时，出现unauthorized 和 is not in the npm registry]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序--登录流程梳理]]></title>
    <url>%2Fpost%2F50039207.html</url>
    <content type="text"><![CDATA[前言微信小程序凡是需要记录用户信息都需要登录，但是也有几种不同的登录方式，但是在小程序部分的登录流程是一样的。之前就朦朦胧胧地用之前项目的逻辑改改直接用了，这个新项目要用就又结合官方文档重新梳理了下，并记录一下，好记性不如烂笔头嘛，哈哈。 几种登录流程设计利用OpenId 创建新用户这种方式我的理解大体上就是一种静默登录，获取用户信息之后解密用户信息并通过OpenId直接创建新用户 利用Unionid 创建新用户这种方式的特点是可以利用Unionid实现多个小程序、公众号、已有登录体系的数据互通。 利用现有登录体系这是笔者目前在使用的一种登录方式，大体上是复用了现有的登录体系，授权获取个人信息之后输入手机号和验证码就能完成登录了，同时OpenId与个人信息都存在了我们自己的服务器。 几个核心API和核心字段 wx.login() 调用接口获取登录凭证（code） code2Session 登录凭证校验,为了获取会话秘钥session_key wx.checkSession() 检查登录态是否过期 wx.getSetting() 获取用户的当前设置 wx.getUserInfo 获取用户信息，获取之后需要解密数据 session_key 会话秘钥，是通过调用接口获取登录凭证获取的，是有时效性的 主要流程最后再附上一张官方文档上登录流程图 总结由于其他两种登录方式还没使用过，我单就使用过的利用现有登录体系这种方式总结一下。 当一个用户来使用我们的小程序时，在一个需要登录的页面，会经历以下几个步骤：tips: 由于最新的文档要求获取用户信息必须用户主动触发，不能开发者自动调取了，所以现在需要做个授权页面引导用户点击 参考 微信官方文档 InterviewMap–小程序]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画和JS动画的比较]]></title>
    <url>%2Fpost%2F6707751a.html</url>
    <content type="text"><![CDATA[前言之前有被问到一个问题，css3动画和js动画性能谁更好，为什么。据我的经验，当然觉得css3动画性能更好，至于为什么一时还真答不上来，所以特意查了一下资料总结一波。 JS动画优点： js动画控制能力强，可以在动画博凡过程中对动画进行精细控制，开始、暂停、终止、取消都是可以做到的 动画效果比css3动画丰富，比如曲线运动，冲击闪烁，视差滚动效果，只有js动画才能完成 js动画大多数情况下没有兼容性问题，而css3动画有兼容性问题 缺点 js动画的复杂度高于css3 js在动画浏览器的主线程中执行，而主线程还有其他javaScript脚本，样式计算、布局、绘制任务等，对其干扰可能出现阻塞从而出现丢帧的情况 js动画往往需要频繁操作DOM的css属性来实现视觉上的动画效果，这个时候浏览器要不停地执行重绘和重排，这对于性能的消耗是很大的，尤其是在分配给浏览器的内存没那么宽裕的移动端。 CSS3动画优点： 部分情况下浏览器可以对动画进行优化，为什么说部分情况下呢，因为是有条件的： 在Chromium基础上的浏览器中 同时CSS动画不触发layout或paint，在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。 在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息，例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。 部分效果可以强制使用硬件加速 （通过 GPU 来提高动画性能） 缺点 运行进程控制较弱，css3动画只能在某些场景下控制动画的暂停与继续，不能在特定的位置添加添加回调函数 js在动画浏览器的主线程中执行，而主线程还有其他javaScript脚本，样式计算、布局、绘制任务等，对其干扰可能出现阻塞从而出现丢帧的情况 css动画比js动画流畅的前提 js在执行一些复杂的任务 css动画比较少或者不触发pain和layout，即重绘和重排，例如通过改变如下属性生成的css动画 backface-visibility opacity perspective （设置元素视图） perspective-origin transfrom 部分属性能够启动3D加速和GPU硬件加速，例如使用transform的translateZ进行3D变换时 在Chromium基础上的浏览器中，这个貌似是内核做了优化，当css动画知识改变transfrom和opacity时，整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行),这样css动画渲染不会影响主线程。 总结回归到日常开发中，当有一个动画的需求时，首要考虑的肯定是能不能尽可能实现的问题。如果在CSS动画和JS动画都能实现的基础上才会要去根据上面总结的权衡哪个性能更好的问题。总之，并不一定css动画就比js动画好，还得看具体的需求和业务场景。 参考文章 css3动画与js动画的区别 CSS3动画和js动画各有什么优劣 css3动画与js动画的一些理解]]></content>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gzip压缩初探]]></title>
    <url>%2Fpost%2F8fd42718.html</url>
    <content type="text"><![CDATA[前言我们平时工作中传文件时为了提高传输速度一般都会把文件压缩一下再传，那样速度回快一些，尤其是那些文件很多的文件夹，比较常用的压缩格式就是zip,rar了。那我们日常网页中利用http协议请求的那些资源可不可以压缩呢，当然是可以了，这就要说到我们今天的主角gzip了。 gzip之前我并没有在项目中用过，就每每查阅文档时听说某一个框架文件经gzip压缩之后就变得多小多小了，甚是好奇，所以今天特意查了一下。 gzip压缩的好处好处当然是很明显的啦，就是可以大大减小传输文件的大小，提高页面加载速度、节省带宽。而且压缩的比率是可以调节的，我们常用的服务器端压缩是3到10倍，一个本来100k的文件能压缩到20k左右，想想都美滋滋，今天看了我们公司的官网用了gzip才发现压缩与不压缩差别还是蛮大的，哈哈。当然并不是所有的文件都能压缩这么多，像我们常用的CSS,JS文件是可以压缩很多的，而图片那些文件本来就压缩过了就没有多少可以压缩了。 gzip压缩的过程gzip是一种流行的文件压缩算法，他会把文件压缩为.gz然后传给浏览器，最后浏览器负责解压文件呈现给客户。所以，要想实现文件的gzip压缩与解压，服务端和浏览器端都得支持。他们的通信过程大体如下： 首先我们要将http请求的请求头中的==accept-encoding==属性设为gzip、deflate，表明浏览器支持gzip压缩方式 web服务器收到浏览器的请求之后，会判断浏览器是否支持gzip压缩，如果支持就传输压缩后的响应内容，如果不支持就传输未压缩的内容。当然，服务器会对压缩文件进行缓存，并不是每次请求都要再压缩一次 浏览器接收到内容后判断文件是否被压缩，如果压缩了就先解压再解析（IE5.5以上才支持gzip） 谁来压缩答案就两个，不是服务端就是客户端。 上面已经讲到了以前常用的一种方式是服务端压缩，浏览器解压。其实我们开发端可是可以压缩的，比如我们日常用的打包软件webpack就有compression-webpack-plugin这么个插件专门做压缩的，大概用法如下：12345678910const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);plugins: [ new CompressionPlugin(&#123; test: /\.js/, //满足正则表达式的会被压缩 filename: &apos;[path].gz[query]&apos;, //目标文件名 algorithm: &apos;gzip&apos;, //使用gzip压缩 threshold: 10240, //资源文件大于10240b=10k时会被压缩 &#125;)] 既然已经存在了服务端响应请求时压缩，为什么还会存在应用构建时压缩这种方式呢？存在并且被很多人使用就一定有它存在的价值，带着这份疑问我查询资料得知：gzip压缩文件是分等级的，共十级。等级越高压缩效果越好可也以为着更耗时嘛。如果你在服务端相应请求时压缩，那我请求一个文件不还是得等好久？而且即便是有了缓存，服务端压缩时还是有时间开销的。 但是构建时压缩就不存在上面这些问题了，我们现在的很多项目都是spa的项目，即使不是也是需要构建工具打包什么的，那我们在这个过程中就最大限度地使用gzip压缩代码，让服务器直接使用不是很好吗，反正我们也不会天天打包生产版本的，哈哈。 当然，这样服务端也得相应地更改配置来读取我们的压缩文件，会要麻烦一些，所以最终使用哪种压缩方式还得根据具有的哑无需求来，但是使用gzip压缩是很有必要的，毕竟效果是摆在那里的。 总结 在之前的一个vue单页面应用中我就遇到过打包之后文件还是太大的问题，当时经过各种分拆和异步组件之后首屏文件还是有一点大，我当时也想到了gzip，可当时的后台忽悠我说很麻烦，可我今天查了一下服务端压缩的话他们也不要加多少配置。所以啊，作为一个前端攻城狮服务端的知识多了解一下还是有必要的，可以防忽悠嘛，哈哈… 今天用uglifyjs-webpack-plugin这个插件配置代码压缩信息时才想起我们这个项目貌似木有使用gzip，于是乎从头了解了一下，所以记录一下。以后要多多利用起来！ 参考 探索HTTP传输中gzip压缩的秘密 HTTP方式下的Gzip压缩传输 webpack4 的生产环境优化 compression-webpack-plugin插件文档]]></content>
      <tags>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个mpvue小程序开发总结]]></title>
    <url>%2Fpost%2Fc9a6ab9.html</url>
    <content type="text"><![CDATA[前言说起小程序，其实在去年我都还只试着照着官方文档写过demo的，不过现在这家公司小程序做得比较多，我来之后也参与了几个小程序的开发了，最开始那几个是用的wepy，最近一个开始转用mpvue开发，最近这个项目终于上线了，我也来试着总结回顾一波吧。 关于框架的选择我刚来现在的公司时，我就了解过有一个小程序框架叫mpvue被美团开源了，有过一个大致的了解。来了公司之后了解到我们公司已经有了一套自己的小程序技术栈那就是基于wepy的，而不是原生小程序，毕竟我们要开发的小程序不是简单的几个页面，而且原生小程序是不支持引入npm包的，原生语法开发的也相对慢一些。我们前端团队之前选择的wepy框架，这是一款腾讯出的小程序框架，类vue的语法，支持引入npm包，比较好地支持组件化开发，这是我们团队开发所必须的。 后来之所以要在最近一个项目中重新选型使用mpvue是因为，在使用wepy的过程中越来越觉得wepy像vue但又不如vue那么好用，而且我们项目一开始就是有计划做H5页面的，mpvue能够最大程度地支持我们代码的复用，而且大体上来说，mpvue能够提供全套的vue环境，包含数据管理vuex，这个跟我们其他用vue全家桶开发项目的切换时无缝的。套用一张网上比较原生、mpvue、wepy和taro的对比图吧（tarp暂时还没使用过，不评价） 项目的搭建我们项目的基本结构是通过vue-cli生成的：1$ vue init mpvue/mpvue-quickstart my-project 然后就是常规的安装依赖和启动了，具体使用看文档。不过在开发过程中为了提高团队的效率以及最大程度上做到和原有的H5项目的一致从而做到最大程度地复用，我们还是改造了部分mpvue-quickstart 模板： 为了集中式页面配置和新增页面热更新，webpack打包的入口文件使用mpvue-entry做统一处理 为了和H5项目有尽可能一致的路由体验，引入了mpvue-router-patch 官方模版默认是没有安装预处理器相关的依赖的，我们项目中用的sass，需要安装node-sass、sass-loader两个依赖 数据请求这块我们使用的是fly.js，也叫flyio，并基于这个做了一些统一的封装，具体用法可以查阅前面提供的文档。之所以选择flyio，是因为它轻量且支持多种JavaScript，这样我们可以在不同项目中最大程度地复用请求代码。具体的封装代码下次专门用篇文章展开。 关于登录和授权上面这张图是官方文档给出的一个完整流程，大体上来说就是先前端先通过用于授权获取code然后发送给我们自己的服务器，服务器通过登录凭证接口去微信接口服务器换取我们所需要的session_key和openid，之后我们与自己服务器之间的数据交互就只要验这个身份唯一标示就可以了。不过新版小程序更新之后用户登录权限需要手动触发了，这个需要注意。 还有一些改造的部分忘记了，先想到这些吧，完整的项目结构可以看我自己重新搭建的一个小项目https://github.com/wanCheng7/mpvue-components，这个项目的解构我基本上是按公司那个项目搭建的，准备放一些常用的组件，后续会逐步完善更新，欢迎带啊支持。 遇到的一些坑1、关于分享功能普通的页面分享给好友可以直接调用子弟你分享按钮1&lt;butto n open-type=&apos;share&apos;&gt;分享&lt;/butto&gt; 由于目前微信是不支持直接分享朋友圈的，所以要想分享朋友圈就只能曲线救国，那就是引导用户将要分享的图片保存到相册再分享这张图片。还有一种常见的场景就是分享我们带有小程序码的自定义图片给朋友或者朋友圈时可以先将这张图片用canvas绘制好，然后预览出来，预览出来之后用户是直接给朋友扫还是保存到手机里那就是用户的选择了。 2、关于页面数据缓存问题因为mpvue中，小程序的生命周期钩子和vue的声明周期钩子是可以同时存在的，虽然官方不建议我们同时用，但是因为小程序一个页面的page在切换页面的过程中是不会销毁的，所以页面上的数据会被缓存起来，也就是说我们改变了A页面上的某些值，去到B页面之后再返回A页面的那些值还是改过之后的。这是我们想看到的吗？看业务情况，如果不是的话可以在onShow这个生命周期钩子里初始化那些变量。 3、关于样式适配问题我印象比较深刻的一个问题是，如果不对页面最外层的盒子设置高度让里面的内容撑开盒子的话，在IOS系统下对底部设置margin和padding都是无效的，一定要设置一个min-height，而安卓没有这个问题。还有一些适配问题一时想不起来了。 总结做完一个项目，真正到了总结时才发现有些问题没有及时总结，等做完项目之后可能都记忆模糊了，所以无论再忙，还是得及时总结才能记录下那些get到的知识点。 还有，就是想到那句话：能说到别人懂才是真的懂，发现自己在总结的过程中有些知识点当时查了资料似乎是懂了，可真正总结出来说给别人看时就有点说不上来了，说明还是理解得不够深入。所以，以后的文章不在于长而在于精，首先一定要坚持写同时每次尽量把一个小的知识点写得稍微深入一点点，加油！ 参考文章 mpvue-docs 小程序开发框架技术分析选型 第一个mpvue小程序开发完了，来总结下吧 理解mpvue的生命周期]]></content>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习笔记（一）——扩展运算符和解构赋值]]></title>
    <url>%2Fpost%2F59cf2dea.html</url>
    <content type="text"><![CDATA[前言随着前端工程化的快速推进，在项目中使用ES6甚至更高的ES7等最近特性早已不是什么新鲜事。之前还觉得既然浏览器支持有限，那了解一下能看懂就好，然而仅仅了解还是不够的，现在放眼望去，那些成熟框架的代码示例都已经开始使用ES6编写了，昨天瞥了一眼vue的源码，已经全部使用ES6编写了。随着开发的进行，发现仅仅了解一下已经不能应付一些日常开发了，因为一些新的特性看起来有点吃力了，所以决定重新学习一下日常开发中见得比较多的ES6特性，争取与实际用例相结合，不仅要认识还要会用，以后多多用起来！当然本文中的ES6就是泛指哈，借用阮一峰老师的定义: ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 扩展运算符rest参数在讲扩展运算符之前得讲一下rest参数，rest参数在我理解来看就是用’…变量名’的形式替代了函数参数中的arguments对象，大概用法如下：12345function testFn (fist, ...rest) &#123; console.log(fist); //1 console.log(rest); //[2,3,4,5]&#125;testFn(1,2,3,4,5); 当然如果在参数中只传入rest参数的话它代表的就是将arguments对象转为数组之后的一个数组，也就是一个包含了所有参数的数组：1234function test2 (...rest) &#123; console.log(rest);&#125;test2(1,2,3); // [1,2,3] 这个对于处理一些不知道参数数量的情况是很方便的，因为一般来说我们也要将argum对象转为数组才方便处理的，下面就是两种不同的写法：12345678910111213141516171819// arguments写法function add1()&#123; var sum = 0; Array.prototype.slice.apply(arguments).forEach( function(item)&#123; sum += item; &#125;) console.log(sum)&#125;add1(1,2,3); //6// rest参数写法function add2(...valus) &#123; let sum = 0; valus.forEach( value =&gt; &#123; sum += value &#125;) console.log(sum)&#125;add2(1,2,3); //6 扩展运算符讲完了rest参数，再讲扩展运算符就可以把它理解为rest参数的逆运算，将一个数组转为用逗号分隔的参数序列：12console.log(...[1,2]); //1,2console.log(8, ...[1,2], 9); //8,1,2,9 再将rest参数和扩展运算符结合起来就是这样的：12345function test3 (...rest) &#123; console.log(rest)&#125;var nums = [1,2,7];test3(...nums); // [1,2,7] 应用： 替代组中的apply方法 12345678var arr4 = [1,2,3];function test4 (a, b, c) &#123; console.log(a)&#125;// ES5写法test4.apply(null, arr4);// ES6写法test4(...arr4); 合并数组 123456789var arr1_ = [1];var arr2_ = [2,3];var arr3_ = [4,5];// ES5var arr4_ = arr1_.concat(arr2_, arr3_);console.log(arr4_); //[1, 2, 3, 4, 5]// ES6var arr5_ = [...arr1_, ...arr2_, ...arr3_]console.log(arr5_); //[1, 2, 3, 4, 5] rest运算符和spread运算符的区别对于三个点号，三点放在形参或者等号左边为rest运算符; 放在实参或者等号右边为spread运算符，或者说，放在被赋值一方为rest运算符，放在赋值一方为扩展运算符。 解构赋值解构的作用是可以快速取得数组或对象当中的元素或属性，而无需使用arr[x]或者obj[key]等传统方式进行赋值 数组的解构赋值 12let [a, b, c] = [1, 2, 3];console.log(a); //1 对象的解构赋值 12let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;console.log(foo); //&quot;aaa&quot; 字符串的解构赋值 12const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot; 数值和布尔值的解构赋值 函数参数的机构赋值 本文同步发表在我的博客园：[https://www.cnblogs.com/wancheng7/p/9697072.html) 参考文章 阮一峰 ES6标准入门 妙用ES6解构和扩展运算符让你的代码更优雅]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所理解的发布订阅模式]]></title>
    <url>%2Fpost%2F9f4d4a04.html</url>
    <content type="text"><![CDATA[神秘的设计模式一直以来，我都感觉设计模式这个东西比较虚，总不知道是用来干嘛的。随着学习的深入，总听到别人说某某地方运用了什么设计模式，于是乎出于好奇就查资料加深了一下理解。目前也还只对发布订阅模式有些简单的理解。说起发布订阅模式，确实在很多地方都能看到它的影子，像JQ时代的trigger和on方法，还有现在的vue中的emit和on方法，之所以想先总结一些我目前所理解的发布订阅模式，是因为目前就这个设计模式了解的多一点，而且前段时间在学习vue双向绑定原理时发现也用到了发布订阅模式，但是不太理解那个里面的用法，所以，一步一步来吧。 发布订阅模式我的理解就是订阅者把自己需要注册的事件名和回调统一注册到一个调度中心，然后当这个事件触发的时候，发布者就会发布到调度中心触发所有注册了这个事件的订阅者的回调。 我看过一个简单的比喻就是发布订阅模式就像我们以前像杂志社订杂志，你会告诉杂志社你需要什么杂志，并且杂志除了之后邮寄到哪里，而杂志社就相当于一个发布者，当最新一期的杂志出来之后他就会先查看某某杂志有哪些人订阅了，然后通知邮递员根据地址分发出去，这个根据不同人订阅时填的地址分发出去的过程实际上就可以理解为订阅者的回调。 实现一个简单的发布订阅模式我们先用一个简单的代码来实现上面例子中的订阅杂志的例子1234567891011121314151617181920212223242526let crop = &#123;&#125;; //自定义一个对象crop.list = &#123;&#125;; //存放缓存毁掉函数crop.on = function(key, fn) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(fn);&#125;crop.emit = function() &#123; let key = [].shift.call(arguments); let fns = this.list[key]; if (!fns || !fns.length) &#123; return &#125; fns.forEach( fn =&gt; &#123; fn.apply(this, arguments) &#125;)&#125;crop.on(&apos;readers&apos;, function(addr)&#123; console.log(&apos;我订阅的《读者》更新了的话请寄到&apos;+addr);&#125;)crop.on(&apos;youth&apos;, function(tel)&#123; console.log(&apos;我订阅的《青年文摘》更新了的话请打我电话：&apos;+tel);&#125;)crop.emit(&apos;readers&apos;, &apos;浙江省杭州市xxx&apos;); // 我订阅的《读者》更新了的话请寄到浙江省杭州市xxxcrop.emit(&apos;youth&apos;, &apos;186xxxx7412&apos;); //我订阅的《青年文摘》更新了的话请打我电话：186xxxx7412 最开始我看到简单的发布订阅模式的实现代码时不时太理解为什么一定要加一个key，其实用订阅杂志这个例子就很好理解了，你不告诉杂志社你订阅的杂志叫什么名字，那我怎么知道要邮寄哪本杂志给你呢，代码层面来说就会将所有订阅者的事件回调执行一次，那肯定不是我们需要的。 通用型实现主要是增加了remove功能，简单理解就是我订阅了某本杂志，中途也是可以退订的嘛，哈哈，那样，就算那本杂志更新了，因为你已经不在通知列表里了，别人照样会通知，可是不会通知你了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 通用型let event = &#123; list: &#123;&#125;, on: function(key, fn) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, emit: function() &#123; let key = [].shift.call(arguments); let fns = this.list[key]; if (!fns || !fns.length) &#123; return &#125; fns.forEach( (fn) =&gt; &#123; fn.apply(this, arguments); &#125;) &#125;, remove: function(key, fn) &#123; let fns = this.list[key]; if (!fns || !fns.length) &#123; return &#125; if (!fn) &#123; fns = [] &#125; else&#123; fns.forEach( (cb, i) =&gt; &#123; if (cb === fn) &#123; fns.splice(i, 1); &#125; &#125;) &#125; &#125;&#125;event.on(&apos;click&apos;, function(name)&#123; console.log(&apos;你的名字是：&apos;+name)&#125;)function cat() &#123;console.log(&apos;一起喵喵喵&apos;);&#125;function dog() &#123;console.log(&apos;一起旺旺旺&apos;);&#125;event.on(&apos;pet&apos;, cat);event.on(&apos;pet&apos;, dog);event.on(&apos;pet&apos;, data =&gt; &#123; console.log(data)&#125;);event.remove(&apos;pet&apos;, dog);event.emit(&apos;click&apos;, &apos;hello world&apos;);event.emit(&apos;pet&apos;, &apos;二哈&apos;) 工作中的应用就像前文讲的，JQ的trigger和on方法、vue中的emit和on方法，包括dom事件模型中的addEventListener和attachEvent等，实际上都是先订阅某个事件，并传入了触发事件的回调。当然还有一些其他用法，像用来做打点什么的，只是我还没实际用过就不多说了。特别提一下vue中的emit和on方法，这个我相信用过vue的都不会陌生，一般来说都是用他们做父子组件之间的通信，说白了就是在父组件中订阅一个自定义方法名和回调，然后在子组件中触发这个自定义事件和回调。 我想，既然这个父子组件的通信也利用的发布订阅模式，而且几个方法都是在vue的实例上的，所以在一些简单页面上做平行组件之间的通信也是可以通过vue实例上的emit和on方法实现的。事实上我尝试过，也是能做到的。只是后面又和同事讨论了一下，这样做平行组件之间通信的话太不稳定了，vue实例上注册的自定义事件容易冲突，而且状态管理也会很混乱，所以还是慎用吧，稍微大一点的项目还是得用vuex做组件之间通信的状态管理。 总结其实将发布订阅模式的大体模式了解清楚之后确实能从很多地方看待他的影子，就我目前的理解来看，主要有这么几点好处吧： 将订阅者和发布者给解耦了，作为发布者来说我不用管谁订阅了要干什么，我只要通知订阅了的对象并执行相应的回调就好了 对于异步编程来说，可以更松耦合的代码编写 至于缺点吧，我查的资料来说主要是 创建订阅者本身需要消耗一定的时间和内存 多个发布者和订阅者嵌套在一起的时候，程序难以跟踪和维护 后面这一点我想大概就是我上文中讲到的处理vue非父子组件之间通信的情况吧，所以总结就是，模式虽好，不可以滥用噢，哈哈，不过正常使用的还是不会有什么的问题的。 而且深入理解这个模式也能够让我们更容易地理解一些框架和解构设计，我相信理解了并好好利用的话一定能对自己的编程能力带来不小的提升！ 下一步，接着硬啃vue双向绑定和框架实现原理，加油！我相信那些一下子看不懂的东西多看几次多查一些资料，将内容拆分消化之后一定能慢慢看懂的！还有就是分享一点感悟，那就是贪多了嚼不烂，我发未知的现焦虑总是促使自己去不停地看新东西，可是由于时间和理解能力的关系往往又没有吃透，甚至有的时候出现了之前了解过查过资料的知识点又在查资料，这样时间的利用率其实是很低的。所以，以后遇到一个想要了解知识点就查资料尽可能地吸收一波之后总结、沉淀，至少要保证之后再遇到这个知识点不需要哦再去查过多的东西，看看自己写的总结和参考文章，那样应该也就回忆的差不多了。 所以，尽可能地深入，并坚持总结吧，加油！ 本文同步发表在我的博客园：https://www.cnblogs.com/wancheng7/p/9575898.html 参考文章 发布订阅模式，在工作中它的能量超乎你的想象 设计模式（三）：观察者模式与发布/订阅模式区别]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动web开发适配方案之Rem]]></title>
    <url>%2Fpost%2F5590b762.html</url>
    <content type="text"><![CDATA[移动端为什么要做适配移动端相对PC端来说大部分浏览器内核都是基于Webkit的，所以大部分都支持CSS3的最新语法。但是由于手机的屏幕尺寸和分辨率都不太一样（尤其是安卓），所以不得不对不同分辨率的手机做适配来达到近似的展示效果。 一般来说，UI只会给我们提供一份设计图，目前比较多的是参考手机淘宝的方案给一份750px宽的设计稿，而我们前端要做的就是在不同分辨率的手机上以同样的效果展示这份设计稿。 在讲适配方案之前，有几个基本的移动端开始相关的知识点得了解一下 rem单位: 说到rem这个单位就不得不提一下在它之前出现的一个类似单位em，em时相对于父级font-size的相对单位，而rem是相对于根节点html的相对单位，也就是说，当html的font-size为12px时，某一个元素的font-size设为1rem也就是等同于12px了。正因为rem单位的这一特性，从而让它可以成为移动端适配的一个关键单位。 vw单位：相对于视窗的宽度，视窗宽度是100vw，与整个单位类似的是wh,就是视窗高度，视窗高度时100vh。更详细的特性可以参考视区相关单位vw, vh..简介以及可实际应用场景 物理像素: 也可以说是设备无关像素，例如iPhone6的分辨率（750x1334）指的是物理像素 逻辑像素: 是浏览器使用的抽象单位，状态是可变的，例如在PC浏览器调试面板上我们可以看到iPhone6的物理像素为(375x667) 物理像素与逻辑像素的关系就是设备像素缩放比dpr 适配思路1、使用CSS的@media媒体查询设置在不同屏幕尺寸下现实不同的效果，类似于这样：1234567891011121314151617@media only screen and (min-width: 375px) &#123; .logo &#123; width : 62.5px; &#125;&#125;@media only screen and (min-width: 360px) &#123; .logo &#123; width : 60px; &#125;&#125;@media only screen and (min-width: 320px) &#123; .logo &#123; width : 53.3333px; &#125;&#125; 首先，这样只照顾了固定分辨率的机型，肯定是不够的，而且，如果针对页面上的每一个元素写这么多套适配也不现实，媒体查询还是比较适合PC端不同分辨率屏幕之间的适配。 2、使用css的单位rem，类似于这样：1234567891011@media only screen and (min-width: 375px) &#123; html &#123; font-size : 62.5px; &#125;&#125;@media only screen and (min-width: 360px) &#123; html &#123; font-size : 60px; &#125;&#125; 当然，在实际开发中不可能真的这样去写，既然上面已经提到了rem这一单位的特性，那么我们要做的就是根据不同分辨率的设备动态地改变html的font-size就好，也就是1rem代表的大小。比较常见的有两种方案： 通过js动态获取屏幕的宽度，从而计算出html的font-size，还是拿日常开发常见的750px的设计稿为例：12345678let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth;let htmlDOM = document.getElementsByTagName(&apos;html&apos;)[0];htmlDOM.style.fontSize = htmlWidth / 7.5 + &apos;px&apos;;window.addEventListener(&apos;resize&apos;, (e) =&gt; &#123; let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth; htmlDOM.style.fontSize = htmlWidth / 7.5 + &apos;px&apos;;&#125;) 这样一来，在375px宽的设备下，html的font-size就是50px,为什么要除以7.5呢，因为这样设计稿上的数值与需要得到的rem值正好是100倍的关系，这样便于换算，当然，引入了scss等预处理工具之后，取多少都不重要了，反正用一个处理函数统一转化一下就可以了,当html的font-size是37.5的时候：1234@function px2rem ($px) &#123; $rem: 75; @return ($px / $rem) + rem;&#125; 另一种方案同样是通过vw这一单位实现rem适配 上面那种方案说白了就是通过JS动态改变html的font-size的大小，而现在有这么一种单位本身的大小就会随着屏幕的变化而变化，那岂不是省去了JS操作Html字体大小的代码！ 我最开始有点担心的是兼容性，不过从caniuse上查的的兼容性上来看兼容性还是比较高的，安卓版本大于4.0的浏览器都是兼容的的。尤其对于在微信上使用的H5页面是完全不用担心兼容性问题的 具体实现如下： 123456 /*当在Ip6下时，100vw代表375px,而视觉稿一般是750px,为了方便算，当html上的1rem代表50px时，视觉稿上的像素跟rem就存在了100倍的转化关闭，而此时1vw代表是3.75px，所以html上的font-siez为50/3.75，约等于13.33333vw,这样即使不用scss也是比较利于换算的 */ html &#123;background-color: #eee; font-size: 13.33333vw;&#125; 设为上面这样一个数值同样是为了计算方便，当然不是必须的，在这样一个数值下，相对应的元素除以100就可以了，写成scss方法如下 1234@function px ($px) &#123; @return ($px / 100) + rem; &#125; .demo2 &#123;width: px(200); height: px(200); background-color: #ddd;&#125; 我看了一下网易新闻的h5页面目前就是使用的这种方案 总结最开始想写这篇文章是因为之前只知道通过JS动态调节html的font-size这么一种适配方案，刚好前段时间接触到了公司的一个移动端项目，我只是单独开发几个页面，但我发现是用的vw单位实现的rem方案，刚开始还觉得蛮新奇的，其实后来查资料仔细一想，跟JS那种方案本质上并没有什么区别，都是以屏幕宽度作为底，动态地调节了html的font-size，也就是1rem的大小。 为了写这篇文章又回看了慕课网上这个视频：移动web开发适配秘籍Rem,真的挺感谢这些大牛无私分享的。就像他所说的，移动web开发适配的方案有许多，然而最好的方案一定要掌握。Rem适配方案是我目前所看到的的使用的最多的，多多了解这种方法背后的原理和熟练掌握这种方法还是挺重要的，再次感谢这些大牛的精彩分享，希望我的总结在提升自己的同时也能帮到别人！ 参考文章： Hello，移动web基础知识整理 移动web开发适配秘籍Rem 移动端H5解惑-页面适配（二） 使用Flexible实现手淘H5页面的终端适配 视区相关单位vw, vh..简介以及可实际应用场景]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究JS中对象的深拷贝和浅拷贝]]></title>
    <url>%2Fpost%2Fad7f4826.html</url>
    <content type="text"><![CDATA[深拷贝和浅拷贝的区别在讲深拷贝和浅拷贝的区别之前，回想一下我们平时拷贝一个对象时是怎么操作的？是不是像这样？1234var testObj1 = &#123;a: 1, b:2&#125;, testObj2=testObj1;testObj1.a = 7;console.log(testObj1); //&#123;a: 7, b:2&#125;console.log(testObj2); //&#123;a: 7, b:2&#125; 发现问题了吗？当testObj1变化时，testObj2相应的属性跟着变化了。这就是属于浅拷贝了，而所谓的深拷贝就是要做到当testObj1变化时testObj2不会跟着变化，这就是浅拷贝与深拷贝的区别。至少在我知道基本类型和引用类型的区别之前我是不知道为什么会这样的，那什么是基本类型和引用类型呢？ 基本类型和引用类型首先通过一个简单的例子看看与上面的例子有什么区别：1234var num1 = 1, num2 = num1;num1 = 7;console.log(num1); // 7console.log(num2); // 1 很显然，这里的变量num2并没有因为num1的变化而变化。其实，这里的num1和num2就是一种基本类型，而上面的那两个对象变量则属于引用类型。 ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值完全保存在内存中的一个位置。而引用类型值是指那些保存堆内存中的对象，意思是变量中保存的实际上只是一个指针，这个指针指向内存中的另一个位置，该位置保存对象。 所以，按我的理解，基本类型就是直接存在内存里的一个具体点，相互之间是独立的，而引用类型存储的只是一个指向具体内存地址的指针，当两个对象相等赋值时，他们实际上是指向的同一个内存地址，所以，当一个变了，另一个跟着变也就不奇怪了。打个不恰当的比喻，基本类型之间就像独立的小超市，相互之间的门头都是不一样的，而连锁超市的话都是一样的，而且都会一起变化。 如何实现深拷贝既然已经知道了深拷贝和浅拷贝的区别以及为什么会出现这种区别，那怎么实现深拷贝呢？我之前在业务开发中有遇到过这个问题，但都是采用先新建一个空对象，再遍历目标对象的属性，将目标对象的属性值一个个赋值给这个新的空对象，从而得到了一个新的对象，这个对象是完全等于之前的对象的，但是不会受它变化而影响，所以算是初步实现了深拷贝的，大体实现如下：12345678var testObj3 = &#123;a: 1, b:2, c:3, d:4&#125;;var testObj4 = &#123;&#125;;for(var key in testObj3)&#123; testObj4[key] = testObj3[key];&#125;testObj3.a = 7;console.log(testObj3); //&#123;a: 7, b:2, c:3, d:4&#125;console.log(testObj4); //&#123;a: 1, b:2, c:3, d:4&#125; 咋一看这个方法当时虽然满足了我当时的业务需求，可是还有什么可以改进的地方呢？还有别的实现方式吗？ 还有什么别的实现方式吗？之前我也没细想过这个问题，知道后来偶尔间看到这篇文章，这篇文章提供的其他方式是我之前不知道，算是补上了我之前知识的盲区，在这里便是感谢。总结来说，还有以下几种方式： 1.通过Onject.assign() Object.assign是ES6中引入的一种用于合并对象的方法，具体使用方法可以看文档 这个方法我之前是用的不多的，但最近几个项目中有些使用后算是知道了这个属性，其实当时就应该可以想到可以用于深拷贝的，大体用法如下： 1234var obj1 = &#123;x: 1, y:2&#125;, obj2 = Object.assign(&#123;&#125;, obj1);obj2.x = 7;console.log(obj1); //&#123;a: 7, b:2&#125;console.log(obj2); //&#123;a: 1, b:2&#125; 可以看到，完美地深拷贝了这个对象，新对象并没有受原对象影响，可是，当对象为嵌套对象的时候呢? 1234var obj3 = &#123;x:1, y:2, z:&#123;name: 3&#125;&#125;, obj4 = Object.assign(&#123;&#125;, obj3);obj4.z.name = 7;console.log(obj3); //&#123;x:1, y:2, z:&#123;name: 7&#125;&#125;console.log(obj4); //&#123;x:1, y:2, z:&#123;name: 7&#125;&#125; 事实证明，对于嵌套对象，Object.assign()深拷贝失效了，所以说，Object.assign()只能实现一维对象的深拷贝 2.通过JSON.parse(JSON.stringify(obj)) 这个方法也是在前一段时间朋友问我深拷贝的方法时偶尔查到的，之前是没用的，感觉还蛮好用的: 1234var obj5 = &#123;x: 1, y:2&#125;, obj6 = JSON.parse(JSON.stringify(obj5));obj6.x = 7;console.log(obj5); //&#123;x: 1, y:2&#125;console.log(obj6); //&#123;x: 7, y:2&#125; 可是这个方法能解决多维对象的深拷贝问题吗？ 1234var obj9 = &#123;x:1, y:2, z:&#123;name: 3&#125;&#125;, obj10 = Object.assign(&#123;&#125;, obj3);obj10.z.name = 7;console.log(obj9); //&#123;x:1, y:2, z:&#123;name: 3&#125;&#125;console.log(obj10); //&#123;x:1, y:2, z:&#123;name: 7&#125;&#125; 从代码上来看，这个方法完美地实现了多维对象的深拷贝，可是这样小小改动一下就会发现有问题了： 1234var obj9 = &#123;x:1, y:2, z:&#123;name: 3, func: function()&#123;&#125;&#125;&#125;, obj10 = Object.assign(&#123;&#125;, obj3);obj10.z.name = 7;console.log(obj9); //&#123;x:1, y:2, z:&#123;name: 3, func: function()&#123;&#125;&#125;&#125;&#125;console.log(obj10); //&#123;x:1, y:2, z:&#123;name: 7&#125;&#125; 是的，当多维对象里有函数时，并没有复制，这是为什么，这个方法的MDN上有解释： undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。 所以，JSON.parse(JSON.stringify(obj))这种方法虽然可以拷贝多维对象，但不能深拷贝含有undefined、function、symbol值的对象。 可以改进的地方 最开始那种通过for.in遍历所有属性的方式是会将原型链上的属性也遍历出来的，一般来说是不要的，所以最好使用obj.hasOwnProperty(key)来进行筛选判断，当然具体情况要根据业务需求来。 后面的几种方法都没有能完美地实现多维数组的深拷贝，所以还得祭出大杀器：递归。简单来说，就是先新建一个新对象，然后通过Object.keys()遍历原对象的所有属性列表，再遍历这个列表，如果有子集也是对象再递归一次，最终得到了深拷贝的对象：123456789101112131415161718192021function deepCopy(obj) &#123; let result = &#123;&#125;; let keys = Object.keys(obj), key=null, tem=null; for(var i=0; i&lt;keys.length; i++) &#123; key = keys[i]; temp = obj[key]; if (temp &amp;&amp; typeof temp === &apos;object&apos;) &#123; result[key] = deepCopy(temp); &#125; else&#123; result[key] = temp; &#125; &#125; return result&#125;console.log(deepCopy(&#123;x:1, y:3&#125;))var obj7 = &#123;x:1, y:3, z:&#123;name: 7, func: function()&#123;&#125;&#125;&#125;;var obj8 = deepCopy(obj7);obj8.z.name = 8;console.log(obj8); // &#123;x:1, y:3, z:&#123;name: 8, func: function()&#123;&#125;&#125;&#125; console.log(obj7) // &#123;x:1, y:3, z:&#123;name: 7, func: function()&#123;&#125;&#125;&#125; 这样，就得到了一个可以兼容多维对象，并且可以实现对function，null，symbol值等特殊值的深拷贝。同时，我们也可以利用第三方库实现深拷贝，如jquery的$.extend和lodash的_.cloneDeep。 针对一种特殊情况的处理本来上面的代码已经几乎完美地实现了深拷贝，但是，有一种特殊情况，就是当拷贝的对象本来就是一个循环引用的对象时，再去递归，那就无穷无尽会爆栈了。像这样的：123456var obj1 = &#123; x: 1, y: 2&#125;;obj1.z = obj1;var obj2 = deepCopy(obj1); 我参考的处理方案就是加一层股票率判断，虽然我觉得这种情况根本就没有什么现实存在的意义，但就当一种临界值的处理吧：12345678910111213141516171819202122232425262728function deepCopy(obj, parent) &#123; let result = &#123;&#125;; let keys = Object.keys(obj), key=null, tem=null, parent_=parent; if (parent_) &#123; if (parent_.originalParent === obj) &#123; return parent_.curentParent; &#125; parent_ = parent_.parent; &#125; for(var i=0; i&lt;keys.length; i++) &#123; key = keys[i]; temp = obj[key]; if (temp &amp;&amp; typeof temp === &apos;object&apos;) &#123; result[key] = deepCopy(temp, &#123; originalParent: obj, curentParent: result, parent: parent &#125;); &#125; else&#123; result[key] = temp; &#125; &#125; return result&#125;obj1.z = obj1;var obj2 = deepCopy(obj1);console.log(obj2); //很多东西 这样，一个深拷贝函数就完成了，对于数组的话是同样适用的，毕竟数组也是特殊的对象嘛，当然实际项目中使用第三方库可能还会更加方便一点，很多时候造轮子并不是为了在项目中使用而是为了了解轮子的构造，这个很重要，之后还会继续造轮子的，这是个深入过膝的过程，加油！ 参考文章： 低门槛彻底理解JavaScript中的深拷贝和浅拷贝]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《BAT前端进阶[师徒班]》学习总结]]></title>
    <url>%2Fpost%2Fa22d4e29.html</url>
    <content type="text"><![CDATA[这是一个培训课是的，这是一个面向中级前端的培训班，但明显跟传统的填鸭式培训班不太一样。这边的老师都是大牛这是毫无疑问的，而且都是一线开发人员。而且课程一开始就说明了面向了是有1-3年有工作经验的前端，所以课程难度还是有些的，信息量也很大，需要自己充分消化吸收。 总体感受说实话，由于课程难度比较大，我在试听了两节课之后有考虑过要不要继续下去(这边承若前几节课觉得不合适是可以全额退款的)。深思熟虑之后我还是想挑战一下自己。其实经过了前几节讲测试的课的懵逼状态之后慢慢感觉还好。主要是块过年放假了，有比较多的时间预习与复习。其中印象深刻就是有个练习要分别用ES5和ES6实现简单的观察者模式，那次的代码琢磨了好久，当然收获也不少。 由于过年之后换工作来杭州了，中间有一个月的课是没有充足准备的，这就使得听课效果非常不理想。由于整个课是面向中级前段的，每周只有周末上几个小时，所以很多东西不会讲那么细，需要自己提前充分预习，在课上提出自己的疑问，这样的学习效果才是最佳的。 课程内容回顾和知识点总结 我在回顾的过程中把课程上所有的主要知识点列了出来，其中有些是有一定的理解了的，但自己还没系统总结过的，我定义为【待总结】，就是还需要写篇文章沉淀一下自己的理解的，另外有些是目前自己都还不能够说出个大概来的，我定义为【待深入理解】，我觉得凡是不能用自己的话讲出的知识点都不算是自己的，最后还有一类就是目前没有使用过的技术或者框架，暂时定义为【待学习】。 Javascript测试（待总结） 因为之前几乎没接触过js测试相关的知识，刚开始还是挺懵逼的，不过随着课程的深入，知道了第一节课先讲测试是因为整个课程是以测试驱动的，我们之后的很多练习和作业都是以测试用例的形式完成，所以长见识了。 JS难点梳理一 this &amp; 变量提升 继承 (待总结) 跨域 (待总结) 模块化 (待总结) 上面几个点是JS最最基础也是最核心的一些点，入行前端这么久肯定都或多或少接触过了，有些也零零散散做过一些笔记，但某某一个知识点总结性的笔记还没做过，所以想通过一片片文章来总结。 JS难点梳理二 设计模式 （待深入理解） 事件模型、事件处理机制 AJAX &amp; fetch （待总结) 这一块就AJAX理解的稍微清楚一点，设计模式概念理解上还比较抽象，事件模型和机制的文章之前有总结过一两篇 前端模版和webpack 前端模版 (待深入理解) webpack (待总结) 异步操作&amp;正则表达式 异步流程控制 (待总结) 正则表达式 正则这一块基本的有做一些总结 基础用法 正则表达式的分组匹配 前端性能优化 HTTP 缓存相关 (待总结) 客户端缓存 加载相关前端性能优化和对象池设计模式 加载相关前端性能优 (待总结) 对象池设计模式 (待深入理解) 上报&amp;安全 上报相关 安全 (待总结) XSS CSRF React 这块目前没有实践过，没什么概念 Node.js 这个就讲的比较泛了，有很多的内容，目前没有深入研究过，之后如果对其中某一个点有研究的话会写文章总结一下的 React深入 由于没有实际用过React，所以其实挺无感的，之后有实际使用过之后再回来看吧 面试 关于面试，准备肯定是必要的 关于之前工作经历，可能的话尽量用STAR面试法叙述，就是工作经验描述中包含情境(situation)、任务(task)、行动(action)、结果(result)，要充分发掘自己所做项目的STAR，尤其是自己负责的某个细分领域，同时，在一个新项目到来时自己可以尝试做技术选型，你不是leader但你可以考虑leader要做的事，并可以跟leader沟通为什么要那样选型 一定要有目标，并且要知道怎么做才能不断接近自己的目标，然后知行合一落地实践。人都是有惰性的，下意识的选择肯定是舒适安逸的。自己要有意识地克服。向上的路并不拥挤，只是大多数人都选择的安逸，真的是这样的，放任自己的本我下意识的选择就是安逸！ 选择比努力重要，现实中知道怎么努力比简简单单地努力更重要 站在一个技术面试官的角度来说，基本要求就是：你进来我不累，你不会天天烦我，说白了就是能马上上手写代码 还有，在描述自己优势的时候，你学习能力很强这不算是亮点，但是你能够讲出如何快速将一个陌生知识转化为自己知识并能够产生生产力的套路的话这就是一个很重要的能力 接下来的路 记得之前某一节课上文坚老师有布置过一个作业，让我们思考自己的长期目标是什么，短期目标是什么，短期目标是否有助于长期目标的实现。我在之前的一篇文章中有总结过，现在想想，大体目标是没什么问题的，但是还应该更细化和落地。比如我的短期目标，就是完善前端的知识体系，那就是要多学、多实践、多沉淀。不要再仅仅做一个API工程师，得往里面深究原理了，落实到具体的行为就是每天要坚持看书、看技术博客，看源码分析了，没什么别的捷径，唯有坚持，别人之所以能当老师在上面吹牛逼因为人家曾经坚持每天学习三四个小时坚持三年，说实话挺厉害的。就目前来说就算加班晚一点每天一个小时的学习是绝对要办证的，目标不落实到行动那就永远是遥远的目标！ 要警惕马太效应，强者愈强，弱者愈弱，这都是一次次选择早就的！ 上面的每个大点基本上对应了每一节课的主要内容，后面的小点就是具体知识点。目前课程虽然已经结束，自己学到了多少通过总结心里是清清楚楚的，凡是那些连基本的总结都做不出来的肯定是没学好没理解的，我希望在接下来的4个月里沿着本课程的学习路径把这些知识点分别深入学习一下，保证每个知识点至少有一篇总结性文章，加油！ 其实整体回顾来看，课程结束了虽然我绝对算不上学的好的，而且当时我是鼓起勇气才花了差不多一个月工资报的这个名，但我不后悔当时选择继续坚持学了下来，因为整个课程收获的不仅仅是前端知识还有眼界和这个一起学习和交流的同行圈子。上课的两位老师无疑都是大牛级别的，但我这个愚钝的学生还是吸收的不够，所以接下来的时间就是一个一个的知识点去回顾，去吸收与总结。整个课程下来指出的那些个细化的知识点，对我来说也算是指引了一条道路。 接下来的路不用考虑太多，既然当初选择了吃技术这碗饭，就先踏踏实实把底子打好先，等达到了技术的baseline才有资格考虑其他，加油！]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析使用vue-router实现前端路由的两种方式]]></title>
    <url>%2Fpost%2F2f3d2375.html</url>
    <content type="text"><![CDATA[关于vue-router由于最近的项目中一直在使用vue，所以前端路由方案也是使用的官方路由vue-router，之前在angularJS项目中也是用过UI-router，感觉大同小异，不过很显然vue-router更友好一些。本文就以vue-router为例浅析我所理解的前端路由，具体用法和一些基本语法就不一一介绍了，官方文档说的更加清晰 关于前端路由据我所知，在现在这些MVC和MVVM框架兴起之前，是不存在前端路由的，页面之间的跳转是由后台控制的。随着前后端分离和单页面应用（SPA）的兴起和WEB项目复杂度的增加，再加上前面这些框架的支持，慢慢前端路由也就成为了现实。单页面应用的特点就是可以在改变URL在不重新请求页面的情况下更新页面视图。 “更新视图但不重新请求页面”是前端路由的原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式 利用URL中的hash（”#”） 利用History interface在 HTML5中新增的方法 下面我们就来看看vue-router是如何通过这两种方式来实现前端路由的 vue-router实现前端路由的方法和对比使用过vue-router的都知道，在vue-router中有mode这样一个参数，这个参数的可选值有”hash”、 “history”、”abstract”1234const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;) 对应我们上面讲到的两种方式来说，hash就是第一种方式，history就是第二种方式，而第三种是在nodejs下的默认实现方式。 那”hash”和”history”这两种方式各有什么优劣呢？ 首先在vue-router中默认使用的是hash这种方式，因为这种方式虽然带个#有点丑（官方竟然都这样说），但是不存在兼容性问题 而history由于底层的实现根据MDN的介绍，调用history.pushState()，所以存在浏览器兼容性问题。 如果不考虑兼容性问题的话，pushState肯定比只修改hash值更加强大，因为可以设置任意同源URL pushState可以设置和当前URL一模一样，这样也会把记录添加到栈中，而hash设置的新值必须和原来不一样 还有，就算不考虑兼容问题的话，history模式还有一个问题，就是history模式会将URL修改的和正常请求后端的URL一样 1http://oursite.com/user/id 这样的话如果后端没有配置对应的user/id这样一个地址的话就会返回404，官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。（这种方案我还没实践过，有机会要实践一下） 所以综合考虑来说用在一些中后台项目中的话一般直接就采用hash这种默认方式了，而前台项目的话看需求选择使用history还是hash 后记在写这篇文章之前看了一个大神写的分析vue-router的文章，每得出一个结论之前都是截取了相应的源文件，真的是做到了 有理有据，实在佩服。我文中之所以没引用是因为实在没有通读过vue-router的源码，也还不是看的太懂，所以就不班门弄斧了，但是在看这篇文章的过程中也慢慢打消了一些对源代码的恐惧，原来源代码也没那么晦涩难懂，认真看还是能看懂大部分的，所以以后移动要多多读这样的文章，慢慢试着去看看源代码，那样得到的结论才是最有一句的，而不是人云亦云，加油！ 参考文章： 【源码拾遗】从vue-router看前端路由的两种实现 VueJs路由跳转——vue-router的使用]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack之proxyTable设置跨域]]></title>
    <url>%2Fpost%2F982e08e3.html</url>
    <content type="text"><![CDATA[为什么要使用proxyTable 很简单，两个字，跨域。 在平时项目的开发环境中，经常会遇到跨域的问题，尤其是使用vue-cli这种脚手架工具开发时，由于项目本身启动本地服务是需要占用一个端口的，所以必然会产生跨域的问题。当然跨域有多种解决方式，这里就不一一例举，下次弄篇文章单独讲，在使用webpack做构建工具的项目中使用proxyTable代理实现跨域是一种比较方便的选择。 如何使用proxyTable还是拿之前使用过的vue-cli举例。我们首先要在项目目录中找到根目录下config文件夹下的index.js文件。由于我们是在开发环境下使用，自然而然是要配置在dev里面：12345678910111213141516dev: &#123; env: require(&apos;./dev.env&apos;), port: 8080, autoOpenBrowser: true, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://www.abc.com&apos;, //目标接口域名 changeOrigin: true, //是否跨域 pathRewrite: &#123; &apos;^/api&apos;: &apos;/api&apos; //重写接口 &#125; &#125;, cssSourceMap: false&#125; 上面这段代码的效果就是将本地8080端口的一个请求代理到了http://www.abc.com这一域名下：1&apos;http://localhost:8080/api&apos; ===&gt; &apos;http://www.abc.com/api&apos; 没有统一项目名下的使用上面那种情况是有一个统一的项目名api的，所以说是比较好匹配的，就相当于说直接将以api开头的接口名代理一下换成目标域名访问就好了，可是如果说后台返给我们前端的接口没有了统一的项目名呢？之前，我是一个个单独去做了转换，接口少还没什么关系，但多了肯定是不现实的，前段时间在一次面试中受到了面试官的启发想到了这样一种取巧的方案：//先人为给接口地址前面加上一个自定义的项目名let someApi = ‘api’ + ‘/xx/xx’; dev: { env: require(‘./dev.env’), port: 8080, autoOpenBrowser: true, assetsSubDirectory: ‘static’, assetsPublicPath: ‘/‘, proxyTable: { ‘/api’: { target: ‘http://www.abc.com&#39;, //目标接口域名 changeOrigin: true, //是否跨域 pathRewrite: { ‘^/api’: ‘/‘ //重写接口 } }, cssSourceMap: false}`这里的项目名api是我们人为加上去的，经过代理之后就没了，这样我们在配置代理这里还是只需要配置一份就够了，只是在写接口地址时要注意区分开发环境和线上环境就可以了。 关于proxyTable的原理我在网上查了一下，这个代理实际上是利用http-proxy-middleware这个插件完成的，具体到这个插件的运行机制，由于是英文再加上能力有限就没深究了。但我想探究的是这种代理方式实际上是如何做到的，我看网上有人说实际上就是我们的本地服务器将请求转发给了目标服务器。之所以出现跨域是因为浏览器有同源策略的限制，但服务器是没有的，所以这种代理方式能够实现的机制大体就是： 本地服务器 –》 代理 –》目标服务器 –》拿到数据后通过代理伪装成本地服务请求的返回值 —》然后浏览器就顺利收到了我们想要的数据 这是我的简单理解，按这个理解来说的话只要服务器允许跨域，任何人都能够拿到它的数据吗？那样同源策略不就大大弱化了吗？目前对这个问题还不是太理解，希望有想法的小伙伴留言指正！ 参考文章 webpack之proxyTable设置跨域 vue-cli 配置 proxyTable 的问题，这样子是最佳解决方案吗？ 详解Vuejs2.0 如何利用proxyTable实现跨域请求]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《免费前端教程不会告诉你这些》知乎LIVE读后感]]></title>
    <url>%2Fpost%2Ff3fa0421.html</url>
    <content type="text"><![CDATA[这个是昨天偶然间在知乎上看到的一个知乎LIVE，答题就是音频在线直播吧，我试听了一下觉得分享的还不错，就买了完整的。主讲人叫方应杭，貌似是个挺牛逼的程序猿，之前没有听过，但这是个典型的科班出生的程序员，全栈，挺佩服他的。接下来就整一些挺的过程中整理的点吧： 作者的自我介绍 首先作者进项了一大段自我介绍，介绍了他从实习开始的工作经历。正如他所说的确实很顺啊，从实习开始就是腾讯，然后转正了去了腾讯，之后又去了阿里等公司。他大体每段工作经历都有讲到，那能从他这些工作经历的介绍中得到什么对自己有用的点呢？ 首先，作者有个习惯，就是在开始项目之前自己会根据项目情况自己造一些轮子，并且以开源框架的要求去封装，这一点给我的启示是自己也要适当地造一些轮子放在github上，看自己能不能做得跟第三方插件一样好甚至某些方面好那么一丢丢。而且这些造的轮子也便于自己日后复用以及面试时跟被人展示自己的技术沉淀。 在工作之余得有个自己的个人项目（side project） 按照作者的观点，要想工作的内容刚好是自己需要学习的知识概率是很小的，那要想学习和实践一些新技术新框架怎么办呢，就是自己在工作之余弄一个自己的项目，在这个项目上自己想用什么框架和技术都是没有限制的。 这样说 来确实挺有必要的。我之前找工作老想着新工作上用到的技术正好是自己需要学习的，可公司不是慈善机构，既然你都还需要在公司里学习，公司干嘛招你呢。所以，在公司工作的过程中能学到自己想学的知识最好，但那些还没接触过的或者最新的技术还得靠自己在工作之余去学习，这个观念得转变过来。 回答网友问题总结 学习知识的形式下过比较一般的是看书，进一步的是提炼总结，再进一步就是输出，写代码或者写文章，最好的方式是讲出来，也就是让别人听懂前端的历史 最开始是没有前端这个职位的，网页是后端程序猿写的，大都用的table布局，没什么css，比较丑 后来又了美工的加入，开始使用div+css布局，变得好看一些了 再之后随着AJAX的普及，慢慢开始专门有些后端程序猿开始专注于写复杂的JS来达到复杂的交互，这就慢慢形成了前端这个岗位 可是最开始HTML是由后端控制的，数据是由后端渲染，这样的话前端是很不爽的，而且前后端不能同时工作，后来就出现了前后端分离 前后端分离意味着前端完全控制HTML/CSS/JS，后端只负责用AJAX的形式提供数据接口，同时人员也彻底分离了，后端专门做后端的事，前端做前端的事 前后端分离也带来了一个问题，就是前端负责的这块显得没有后端那么重要，所以晋升难一些，事实上也确实是这样，不过后来移动端的兴起使得前端负责的东西多了一块，也稍微显得重要一些了 再之后就是各种随着HTML5和CSS3以及ES56的部分基础设施的完善和升级，前端框架开始向各种优秀语言抄，也就出现了现在的MVC和MVVM等框架 入门指导 书籍推荐 javascript.ruanyifeng.com es6.ruanyifeng.com 你不知道的 JavaScript CSS 揭秘 项目推荐 原生 JS 仿网易云音乐、饿了么（后端使用 leanCloud） Vue 或 React 再实现一遍 网站推荐 MDN CSS Tricks Codrops 优质的中文前端博客 （1.4k）https://github.com/FrankFang/best-chinese-front-end-blogs 学习思路推荐 仿你看到的所有东西：hao123、知乎、微信 Follow 我的 GitHub https://github.com/FrankFang/resume-15-3 https://github.com/FrankFang/nav-demo https://github.com/FrankFang/canvas-demo-2017 看完任意一本教程 给一年前端 从 60 分到 80 分，关注用户体验 模仿组件 不要重复自己 不要满足于调用 API 三年前端 关注工作效率 做份外的事情：后端、设计、产品 管理上级、拢络平级 变成重要的人 坚持写博客 模仿框架 跟人（榜样）学，而不是跟视频、书学 社区里的人 公司里的人 互联网上的人 我的收获 增长见识 首先作为一个非计算机科班的我第一次比较完整的了解了一个优秀科班生的从业经历，当然作者自己都说了，他算是比较顺风顺水型，但至少能看出学计算机专业的在编程领域真的有更多的可能性 另外一点就是关于前端这个职位的发展，毕竟我不是从有这个职位就开始做前端的，这次算是从作者口中间接了解了前端这个一个职位的发展史 学习方法 我们之所以喜欢看名人传记，就是想从他们身上找到一些我们能够学习的优秀特质。听他人的技术分享也是一样的道理。虽热作者在分享过程中几乎没有说过要我们学他怎么样的话，但从他一些细节和习惯的描述中我们可以选择性的学习一些优秀特质，例如： 在开始项目之前自己先试着造个轮子 工作之余做side project，在这种项目上学习新知识，而不是工作中 工作中尝试封装组件，并且以能够给别人使用为目标，无论有没有人用 我觉得作者身上表现的这些点一定算是他成功路上的优秀特质，我们不一定要都学会，但是可以结合自身情况来学习一下 关于前端学习之路 前端知识比较分散，数量庞杂，最终还是要多练，多记吧，这肯定是必由之路。我之前听人说过一种观点，前端就是在记各种API和熟练使用各种API，当然，这是中低层主要在做的事情，也是每一个优秀前端的基本功。至于更高层级的话，按作者的说法就是不仅仅要满足于会用现成的API了，而是要想着怎么造好用的API给别人使用，当然造这个的前提是了解原理了，所以这个阶段就是不仅要知道怎么用，还得知道为什么要这么用了，我正在朝这个方向努力，加油！ 关于作者提出的向人学习这一点我有些疑问？ 因为之前一直有种观点就是不要轻易去问人，因为没经过自己思考就去问人那样得到的答案记得确实没那么深刻。所以说关于作者提出的跟人学而不是跟视频什么的学，我的理解是多交流，当你身边坐着一位大牛的时候，你把问题和思路直接跟他说，那样能够得到及时的反馈肯定是最高效的，当然这种问题都是一些思路啊方法层面的了。 所以，我的总结就是，基础的东西一定要自己查自己记住，而一些方法啊原理层面的东西，有资源的情况下尽量找比你牛逼的人交流解决，那肯定是要高效一些的。 谈谈个人的长期目标和短期目标 从15年毕业后经过培训进入前端行业到现在真正从事前端的时间也有两年多了，前一年几乎是没有任何目标感的，也不知道自己需要什么，公司需要什么就学什么，感觉有点浑浑噩噩混着的感觉。大概也就从去年开始才开始有了不仅仅要满足于解决现有问题，还应该多去了解基础和底层原理了。 首先谈谈短期目标吧 短期目前就是在最近两年内完善自己的知识体系，成为前端小组长或者负责人。我目前理解的这个知识体系是从计算机原理到浏览器执行机制、HTTP协议、JS的最新规范以及适当的了解目前流行的前端框架及其出现的原因。这些不一定要面面俱到，但每个方面都要有涉及，不能遗漏。 长期目标 目前来说长期目标就是在前端之外探寻更多的可能性，也就是是说看在前端知识体系基本完善的情况下结合别的方面的能力。最好的话就是能够走管理或者培训吧。技术这条路是没有尽头的，每个公司需要的技术牛人毕竟是有限的，尤其是中小型公司，而每个公司都需要能够提升团队工作效率，尽快带来产出的leader，我想，我的长期目标就是成为一个这样能够推进项目发展的leader。 我的短期目标是长期目标的基础，也是我来杭州的目的，我相信只要这个短期目前完成的好的话长期目标就是积累加机遇的过程了！ 最后附上作者的知乎LIVE免费前端教程不会告诉你这些]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS正则表达式的分组匹配]]></title>
    <url>%2Fpost%2F41ca68e.html</url>
    <content type="text"><![CDATA[什么是分组通俗来说，我理解的分组就是在正则表达式中用（）包起来的内容代表了一个分组，像这样的：12var reg = /(\d&#123;2&#125;)/reg.test(&apos;12&apos;); //true 这里reg中的(/d{2})就表示一个分组，匹配两位数字 分组内容的的形式一个分组中可以像上面这样有一个具体的表达式，这样可以优雅地表达一个重复的字符串12/hahaha//(ha)&#123;3&#125;/ 这两个表达式是等效的，但有了分组之后可以更急简洁。 体格分组中还可以有多个候选表达式，例如123var reg = /I come from (hunan|hubei|zhejiang)/;reg.test(&apos;I come from hunan&apos;); //truereg.test(&apos;I come from hubei&apos;); //true 也就是说在这个分组中，通过|隔开的几个候选表达式是并列的关系，所以可以把这个|理解为或的意思 分组的分类分组有四种类型 捕获型 () 非捕获型 (?:) 正向前瞻型 (?=) 反向前瞻型 (?!)我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串 分组的应用分组在正则中还算使用的比较广泛的，我们常用的是捕获型分组 捕获与引用 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：123456var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var dateStr = &apos;2018-04-18&apos;;reg.test(dateStr); //trueRegExp.$1 //2018RegExp.$2 //04RegExp.$3 //18 结合replace方法做字符串自定义替换 String.prototype.replace方法的传参中可以直接引用被捕获的串，比如我们想开发中常见的日期格式替换,例如后台给你返回了一个2018/04/18,让你用正则替换为2018-04-18，就可以利用分组123var dateStr = &apos;2018/04/18&apos;;var reg = /(\d&#123;4&#125;)\/(\d&#123;2&#125;)\/(\d&#123;2&#125;)/;dateStr = dateStr.replace(reg, &apos;$1-$2-$3&apos;) //&quot;2018-04-18&quot; 不过这里需要注意的是/是需要用\转义的 反向引用 正则表达式里也能进行引用，这称为反向引用： 12345var reg = /(\w&#123;3&#125;) is \1/reg.test(&apos;kid is kid&apos;) // truereg.test(&apos;dik is dik&apos;) // truereg.test(&apos;kid is dik&apos;) // falsereg.test(&apos;dik is kid&apos;) // false 需要注意的是，如果引用了越界或者不存在的编号的话，就被被解析为普通的表达式 123var reg = /(\w&#123;3&#125;) is \6/;reg.test( &apos;kid is kid&apos; ); // falsereg.test( &apos;kid is \6&apos; ); // true 非捕获型分组 有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组，例如12345var reg = /(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/var date = &apos;2012-12-21&apos;reg.test(date)RegExp.$1 // 12RegExp.$2 // 21 正向与反向前瞻型分组 正向前瞻型分组：你站在原地往前看，如果前方是指定的东西就返回true，否则为false 123var reg = /kid is a (?=doubi)/reg.test(&apos;kid is a doubi&apos;) // truereg.test(&apos;kid is a shabi&apos;) // false 反向前瞻型分组：你站在原地往前看，如果前方不是指定的东西则返回true，如果是则返回false 123var reg = /kid is a (?!doubi)/reg.test(&apos;kid is a doubi&apos;) // falsereg.test(&apos;kid is a shabi&apos;) // true 既然前瞻型分组和非捕获型分组都不会捕获，那他们有什么区别呢？先看例子： 12345678var reg, str = &quot;kid is a doubi&quot;;reg = /(kid is a (?:doubi))/reg.test(str)RegExp.$1 // kid is a doubireg = /(kid is a (?=doubi))/reg.test(str)RegExp.$1 // kis is a 也就是说非捕获型分组匹配到的字符串任然会被外层分组匹配到，而前瞻型不会，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。 参考文章 JavaScript正则表达式的分组匹配详解 正则表达式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究JS中的连等赋值问题]]></title>
    <url>%2Fpost%2Fc080eeb1.html</url>
    <content type="text"><![CDATA[一、引子最近在看别人的博客时无意中看到一个这样的问题1234567var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n:2&#125;;console.log(a.x); //undefinedconsole.log(a); // &#123;n: 2&#125; console.log(b); // &#123;n: 1, x: &#123;n: 2&#125;&#125; 这是一个典型的连等赋值问题，是不是发现打印的结果跟自己预料的不太一样，就算一样你能具体讲出内部的执行机制吗？ 二、直观理解咋一看这个表达式，我会本能地把它拆解为这样12a=&#123;n:2&#125;;a.x=&#123;n:2&#125;; 所以根据这个理解得出的打印结果是1console.log(a.x); //&#123;n: 2&#125; 显然结果是不对的，那问题出在了哪里呢？要想从原理上解释这个问题，还得首先理解以下几个知识点 三、需要理解的知识点 内存的的运行机制 JS引擎的解析过程，从左往右 连等赋值的执行方向，从右往左 放在这个例子中对应的理解就是： a、b这些变量名存储的只是一串指向具体对象的指针，这些指针占用的空间是非常小的，而{n: 1}这些对象才是实实在在存在内存中的值 JS引擎在执行到a.x = a = {n:2}这句时，并不是直接的从右往左的执行过程。而是计算机会先从左往右解析各个变量名，转换成变量值（计算机只会记变量值，人的话记变量名）。再从右往左执行赋值。 也就是在这个表达式中第一个a和第二个a指向的都是{n: 1}; 1a.x = a = &#123;n:2&#125; 解析完成后，从右往左执行赋值,第二个等号赋值时，a重定向到了{n: 2},第一个等号赋值时，实际上是{n:1}.x={n, 2};而这个时候指向{a:1, x:{n:2}}这个值的只有b了 所以a.x的值就变为了undefined，因为a已经重定向赋值为{n:2}了，而b就指向了复合之后的对象 四、理解中的误区及思考我最开始查了连等赋值的相关文章时，对于以上这些原理的理解是没什么问题的，关键是在理解最后那个赋值过程时，我有过一种理解123a = &#123;n:2&#125;;a.x=&#123;n:2&#125;;// 所以此时a= &#123;n:2, x:&#123;n:2&#125;&#125; 产生这种理解的原因是觉得对a的赋值有个先后顺序，但事实上好像是不存在的。我对上面那种从解析赋值角度去理解的核心就是在连等赋值执行过程中，总共分为两步，一步是变量名解析，一步是赋值，然后根据赋值之后的值去看相应的变量名与变量之间的对应关系。 五、参考文档 深入理解JS的连等赋值伸 写了 10 年 Javascript 未必全了解的连续赋值运算 由ES规范学JavaScript(二)：深入理解“连等赋值”问题]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原理探究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中将对象转化为数组]]></title>
    <url>%2Fpost%2F4da1c743.html</url>
    <content type="text"><![CDATA[前言其实这本来应该是一个很基础的问题了，但我之做一想记录一下是因为之前因为对象转数组的时候卡住了后来弄了出来，但最近再遇到这个问题时竟然又卡主了，所以，关于这个问题，如何把一个对象{‘未完成’:5, ‘已完成’:8, ‘待确认’:4, ‘已取消’:6}转为[{“未完成”:5},{“已完成”:8},{“待确认”:4},{“已取消”:6}]，你已经知道如何操作了，那这篇文章你也就没有必要看了。 对象的两种取值方式我们都知道，JS中对象有两种取值方式，通过在.后面直接加属性名取值，这也是我们最常使用的一种方式，例如:12let obj = &#123;name: &apos;wan&apos;&#125;;console.log(obj.name); //wan 这是最普通的一种方式，还有一种方式我们用的不太多，就是使用[]包住属性名取值，类似于数组那样，例如12let obj = &#123;name: &apos;wan&apos;&#125;;console.log(obj[name]); //wan 那二者之前有什么区别呢，如果对于一个已知的对象来说，几乎是没什么区别的，但是如果我们需要的对象的key是变量呢？这就回到了我们文章开始是提到的问题，如何将一个对象转化为数组 将对象转化为数组我们文章开始例子中的对象是1let obj = &#123;&apos;未完成&apos;:5, &apos;已完成&apos;:8, &apos;待确认&apos;:4, &apos;已取消&apos;:6&#125;; 如果目标数组只是为了得到对象的key的集合或者value的集合还是相对容易的123456var arr = []for (let i in obj) &#123; arr.push(obj[i]); //属性 //arr.push(obj[i]); //值&#125;console.log(arr); 如果像我文中开始的需求的话就只需要改变一下push进去的内容为一个对象即可1234567var arr = []for (let i in obj) &#123; let o = &#123;&#125;; o[i] = obj[i]; arr.push(o)&#125;console.log(arr); 后记说到底还是思维不够灵活在解决问题时就卡克了，说实话这不是一个什么难题，但是把自己思维限制死了之后就会觉得是个难题，谨记！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS种正则表达式的基础用法]]></title>
    <url>%2Fpost%2F10937cb.html</url>
    <content type="text"><![CDATA[基础语法元字符 常用元字符 含义 . 匹配除换行符以外的任意字符 \w 匹配字母数字或下划线 \W 匹配不是字母、数字、下划线的字符 \d 匹配数字，相当于[0-9] \D 匹配不是数字的字符 \s 匹配任意不可见字符，包括空格、制表符、换行符等 \S 匹配任意可见字符 ^ 匹配字符串的开始位置 $ 匹配字符串的结束位置 量词 量词 含义 * 重复任意次，相当于{0,} ? 重复0次或1次，相当于{0，1} + 重复1次或更多次，相当于{1，} {n} 重复n次 {n,} 重复n次或者大于n次 {n,m} 重复n到m次 分支&amp;字符集简单理解就是对某个字符界定的一个选择范围 (a|b|c) [abc] === [a-c] [^abc] === [^a-c] 转义使用\转义，我的理解是凡是不是表达它原本含义的字符就要转义，例如12345/\d/ 表示的是匹配纯数字/\\\d/ 表示的是匹配&apos;\d&apos;这个字符串/\d/.test(&apos;2&apos;) //true/\\\d/.test(&apos;2&apos;) // false/\\d/.test(&apos;\\d&apos;) //true 当然，这还只是针对以\开头的那些元字符，还有那些量词当表示普通字符串时也要转义的，大体有这些： . ? + $ ^ [ ] ( ) { } | \ / 常用修饰符 g → 全局搜索(global) i → 不区分大小写(ignoreCase) m → 多行搜索(multiline) y → 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。(sticky) 使用正则表达式正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。 实例既然前面讲了这么多基本规则，那就试着手写两个日常业务中常见的正则吧 验证手机号 123最简单的验证：/^1[0-9]&#123;10&#125;$/.test(&apos;18688888888&apos;) //true这只是对开始的一位数和后面的10位数做了简单验证，如果需求有别的还可以根据位数做更精细的限制 验证邮箱 邮箱验证正则是个老生常谈的问题了，有很多前端笔试题也喜欢出，之前没有细化了解正则规则之前觉得这题目挺变态的，但现在觉得能够徒手写个简单的邮箱验证出来才能至少证明你了解基本的正则，话不多少，上代码：123首先看一个正确的邮箱地址：525918717@qq.com这里可以差分为&apos;525918717&apos;、&apos;@&apos;、&apos;qq&apos;、&apos;.&apos;、&apos;com&apos;这么几部分，那么对应这几部分的内容初略匹配一下正则就是：/^\w+@(\w+)\.([a-z]+)$/i.test(&apos;525918717@qq.com&apos;) //true 当然，这只是我自己手写的一个基础版，还有更精简的版本，例如1/[^\s@]+@[^\s@]+\.[^\s@]+/.test(&apos;525918717@qq.com&apos;) //true 经过对正则一些基础语法的了解，我对正则的理解就是想达到同一个匹配效果可以有多重方式，当然还有一些更高级的用法，像零宽断言和分组引用这些，下次用一篇文章单独讲解吧！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用popstate事件和window下的history对象处理浏览器跳转问题]]></title>
    <url>%2Fpost%2Fe384a99a.html</url>
    <content type="text"><![CDATA[引子之前，偶尔在项目中用过history接口做返回上一页功能，当时是用的history.go(-1)，前几天面试中遇到一个控制浏览器跳转的问题时有点懵，特意查了文档记录一下，并且列出一些目前能想到的应用： popstate事件文档地址 当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。 就我目前的认识来看，无论是浏览器的前进还是后退都会触发这个popstate事件，所以只能起到一个监听页面变化的作用。 History 接口 属性 History.length 表示历史会话中元素的数目 History.scrollRestoration 允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的（auto）或者手动的（manual）。 History.state 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。 方法 History.back() 等同于history.go(-1) History.forward() 等同于historygo(1) History.go() 这个方法中如果参数超出范围或者不对就不会起效果 History.pushState() pushState() 带有三个参数：一个状态对象，一个标题（现在被忽略了），以及一个可选的URL地址。下面将对这三个参数进行细致的检查 1234567function pushHistory() &#123; var state = &#123; title: &quot;title&quot;, url: &quot;#&quot; &#125;; window.history.pushState(state, &quot;title&quot;, &quot;#xx&quot;); &#125; 其他方法就不一一列举了，感兴趣的看文档 监听浏览器返回按钮123456789101112function pushHistory() &#123; var state = &#123; title: &quot;title&quot;, url: &quot;#&quot; &#125;; window.history.pushState(state, &quot;title&quot;, &quot;#xx&quot;); &#125;pushHistory();window.addEventListener(&quot;popstate&quot;, function(e) &#123; console.log(e); alert(&quot;我监听到了浏览器的返回按钮事件啦&quot;);//根据自己的需求实现自己的功能 &#125;, false); 这个地方就监听了浏览器的返回事件，但我有个疑问，如果不先pushState一个地址就监听不到，直接跳转了，这个暂时没搞懂，有知道的小伙伴可以留言讨论一下。 禁止返回上一页的一种方案12345history.pushState(null, null, document.URL);window.addEventListener(&quot;popstate&quot;,function(e) &#123; console.log(e); history.pushState(null, null, document.URL);&#125;, false); 这个其实就是利用pushState向浏览历史列表中插入当前页面，在点击后退前和点击时都插入一次，那样无论点前进还是后退永远都会留在这个页面了 如果大家还有什么关于利用history接口和popstate结合控制页面跳转的实际应用案例，欢迎留言讨论交流！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>web API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo从零开始在githubpage上搭建自己的个人博客]]></title>
    <url>%2Fpost%2F6af8e2ee.html</url>
    <content type="text"><![CDATA[主要参考了以下两篇文章： 使用Hexo+Github一步步搭建属于自己的博客（基础）：https://www.cnblogs.com/fengxiongZz/p/7707219.html 使用Hexo+Github一步步搭建属于自己的博客（进阶）：http://www.cnblogs.com/fengxiongZz/p/7707568.html 手把手教你用Hexo+Github搭建属于自己的博客(详细图文)：http://www.jb51.net/article/125152.htm]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>填坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 折腾记录]]></title>
    <url>%2Fpost%2F5f818014.html</url>
    <content type="text"><![CDATA[部署遇到的坑 部署时遇到这个报错：’bash: /dev/tty: No such device or address’…后面还一大堆，这个在第一次上传到github仓库时时没出现过的，这次修改之后出现了，网上查了之后说是配置问题，具体哦如下： 123456_config.yml文件中，找到Deployment： deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 其中 repo的地址修改为git@github.com:yourname/yourname.github.io.git 经过修改之后就可以了 参考网站：https://www.zhihu.com/question/38219432 hexo next主题集成gitment评论系统主要草考文章：https://blog.csdn.net/yanzi1225627/article/details/77890414 hexo链接持久化由于hexo默认的链接形式是年月日加上文章名，而我们是中国人在文章命名时一般是中文的这样就会造成文章链接中有中文，这样会带来一些问题，像上面的giment就要求链接中不能有中文，还有链接长了不利于SEO，当然我目前没有这个需要，但还是参考大神的文章将链接成短的持久化的链接了：参考文章：hexo链接持久化终极解决之道 增加搜索功能参考文章：hexo 搜索功能 其他优化和折腾参考链接 hexo 摸爬滚打之进阶教程 hexo的next主题个性化配置教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>填坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用操作命令]]></title>
    <url>%2Fpost%2Fb0551089.html</url>
    <content type="text"><![CDATA[新建一篇文章，如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。1$ hexo new [layout] &lt;title&gt; 生成静态文件1$ hexo g 启动服务器1$ hexo server 启动服务器，使用新端口1$ hexo server -p 部署网站1$ hexo d 生成静态文件并部署网站1$ hexo d -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>常用命令行</tag>
      </tags>
  </entry>
</search>
